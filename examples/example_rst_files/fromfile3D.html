

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Example: Batch Adaptive Sampling (3-to-3 example) &mdash; BET 2.1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Example: Linear Map with Uniform Sampling" href="linearMapUniformSampling.html" />
    <link rel="prev" title="Example: Batch Adaptive Sampling (2-to-2 example)" href="fromfile2D.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> BET
          

          
          </a>

          
            
            
              <div class="version">
                2.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parallel.html">Parallel</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../examples_overview.html">Some References and Examples</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../examples_overview.html#validation-example">Validation example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples_overview.html#linear-map-example">Linear Map Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples_overview.html#non-linear-map-example">Non-Linear Map Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples_overview.html#fenics-example-serial-bet-and-serial-model">FEniCS Example (serial BET and serial model)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples_overview.html#adcirc-on-an-idealized-inlet-examples-and-adaptive-sampling">ADCIRC on an Idealized Inlet Examples and Adaptive Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples_overview.html#contaminant-transport-example">Contaminant Transport Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples_overview.html#choosing-optimal-qois-examples">Choosing Optimal QoIs Examples</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../examples_overview.html#list-of-all-examples">List of all examples</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="FEniCS.html">Example: FEniCS</a></li>
<li class="toctree-l3"><a class="reference internal" href="FEniCSMultipleSerial.html">Example: Multiple Serial FEniCS</a></li>
<li class="toctree-l3"><a class="reference internal" href="Q_1D.html">Example: Estimate the parameter space probabiliy density with  a 1D data space</a></li>
<li class="toctree-l3"><a class="reference internal" href="Q_2D.html">Example: Estimate the parameter space probabiliy density with  a 2D data space</a></li>
<li class="toctree-l3"><a class="reference internal" href="Q_3D.html">Example: Estimate the parameter space probabiliy density with  a 3D data space</a></li>
<li class="toctree-l3"><a class="reference internal" href="chooseOptQoIs_2d.html">Example: Optimizing space-time measurements of temperature on a thin plate</a></li>
<li class="toctree-l3"><a class="reference internal" href="contaminantTransport.html">Example: Concentration of Contaminant in Wells Based on Transport Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="domains2D.html">Example: Generalized Chains with a 2,2-dimensional data,parameter space</a></li>
<li class="toctree-l3"><a class="reference internal" href="domains3D.html">Example: Generalized Chains with a 3,3-dimensional data,parameter space</a></li>
<li class="toctree-l3"><a class="reference internal" href="fromfile2D.html">Example: Batch Adaptive Sampling (2-to-2 example)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Example: Batch Adaptive Sampling (3-to-3 example)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#generating-a-single-set-of-adaptive-samples">Generating a single set of adaptive samples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generating-and-comparing-several-sets-of-adaptive-samples">Generating and comparing several sets of adaptive samples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="linearMapUniformSampling.html">Example: Linear Map with Uniform Sampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="linear_measure_binratio.html">Example: Linear Map Choose QoIs to minimize scale of inverses in measure</a></li>
<li class="toctree-l3"><a class="reference internal" href="linear_measure_binsize_large.html">Example: Linear Map Choose QoIs (volume / bin_size / large)</a></li>
<li class="toctree-l3"><a class="reference internal" href="linear_volume_binratio.html">Example: Linear Map Choose QoIs (volume / bin_ratio)</a></li>
<li class="toctree-l3"><a class="reference internal" href="nonlinearMapUniformSampling.html">Example: Nonlinear Map with Uniform Sampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="validation.html">Example: Validation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">bet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../todo_list.html">Todo List</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BET</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../examples_overview.html">Some References and Examples</a> &raquo;</li>
        
      <li>Example: Batch Adaptive Sampling (3-to-3 example)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/examples/example_rst_files/fromfile3D.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="example-batch-adaptive-sampling-3-to-3-example">
<span id="fromfile3dexample"></span><h1>Example: Batch Adaptive Sampling (3-to-3 example)<a class="headerlink" href="#example-batch-adaptive-sampling-3-to-3-example" title="Permalink to this headline">Â¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This example shows how to generate adaptive samples in a specific
way by implicitly defining an input event of interest. It does NOT
show how to solve the stochastic inverse problem using these samples,
which can be found by reading other examples. Thus, we only present
the first few steps involved in discretizing the parameter and data
spaces using a specific type of adaptive sampling. The user is
referred to some other examples for filling in the remaining steps
for solving the stochastic inverse problem following the construction
of the adaptive samples.</p>
</div>
<p>We will walk through the following <a class="reference external" href="https://github.com/UT-CHG/BET/blob/master/examples/fromFile_ADCIRCMap/fromFile3D.py">example</a>
that uses a linear interpolant of a 3-dimensional QoI map used
to define a 3-dimensional data space.
The parameter space is also 3-dimensional.</p>
<p>This example specifically demonstrates the adaptive generation of samples
using  a
goal-oriented adaptive sampling algorithm.
This example is based upon the results shown in Section 8.6 of the
manuscript <a class="reference external" href="http://dx.doi.org/10.1016/j.advwatres.2015.01.011">Definition and solution
of a stochastic inverse problem for the Manningâs n parameter field in
hydrodynamic models</a>
where the QoI map is given by
<span class="math notranslate nohighlight">\(Q(\lambda) = (q_1(\lambda), q_5(\lambda), q_2(\lambda))\)</span>.
We refer the reader to that example for more information about the
physical interpretation of the parameter and data space, as well as
the physical locations of the observation stations defining the QoI map.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this example, we have used ADCIRC to generate data files
based on a regular discretization of the parameter space whose
sole purpose is to create an (accurate) surrogate QoI map defined as a
piecewise linear interpolant. This is quite different from many of the
other examples, but the use of the surrogate QoI map is immaterial. The
user could also interface the sampler directly to ADCIRC, but this would
require a copy of ADCIRC, the finite element mesh, and significant
training on the use of this state-of-the-art shallow water equation code.
The primary focus of this example is the generation of adaptive samples.
If the user knows how to use the ADCIRC model, then the user may instead
opt to significantly change Step (1) below to interface to ADCIRC instead
of to our âmodelâ defined in terms of the surrogate QoI map.
Interfacing to ADCIRC directly would likely require the use of <a class="reference external" href="https://github.com/UT-CHG/PolyADCIRC">PolyADCIRC</a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This example is very similar to <a class="reference internal" href="fromfile2D.html#fromfile2dexample"><span class="std std-ref">Example: Batch Adaptive Sampling (2-to-2 example)</span></a> which involved
a 2-to-2 map. The user may want to modify either example to involve fewer
QoIâs in the map (e.g., defining a 2-to-1 or 3-to-2 or 3-to-1 map). The
example discussed in Section 8.6 of the paper referenced above discusses
that the results for solving the stochastic inverse problem using a 3-to-3
map are almost identical to those using a 3-to-2 map.</p>
</div>
<div class="section" id="generating-a-single-set-of-adaptive-samples">
<h2>Generating a single set of adaptive samples<a class="headerlink" href="#generating-a-single-set-of-adaptive-samples" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="step-0-setting-up-the-environment">
<h3>Step (0): Setting up the environment<a class="headerlink" href="#step-0-setting-up-the-environment" title="Permalink to this headline">Â¶</a></h3>
<p>Import the necessary modules:::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">bet.sampling.adaptiveSampling</span> <span class="k">as</span> <span class="nn">asam</span>
<span class="kn">import</span> <span class="nn">bet.postProcess.plotDomains</span> <span class="k">as</span> <span class="nn">pDom</span>
<span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="nn">sio</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">griddata</span>
</pre></div>
</div>
</div>
<div class="section" id="step-1-define-the-interface-to-the-model-and-goal-oriented-adaptive-sampler">
<h3>Step (1): Define the interface to the model and goal-oriented adaptive sampler<a class="headerlink" href="#step-1-define-the-interface-to-the-model-and-goal-oriented-adaptive-sampler" title="Permalink to this headline">Â¶</a></h3>
<p>This is where we interface the adaptive sampler imported above
to the model.
In other examples, we have imported a Python interface to a
computational model.
In this example,  we instead define the model as
a (piecewise-defined) linear interpolant to the QoI map <span class="math notranslate nohighlight">\(Q(\lambda) =
(q_1(\lambda), q_5(\lambda), q_2(\lambda))\)</span> using data read from a <code class="docutils literal notranslate"><span class="pre">.mat</span></code>
<a class="reference external" href="https://github.com/UT-CHG/BET/blob/master/examples/matfiles/Q_3D.mat">file</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">station_nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># 1, 5, 2</span>
<span class="n">mdat</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s1">&#39;Q_3D&#39;</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">mdat</span><span class="p">[</span><span class="s1">&#39;Q&#39;</span><span class="p">]</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[:,</span> <span class="n">station_nums</span><span class="p">]</span>
<span class="c1"># Create experiment model</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">mdat</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
    <span class="n">interp_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">inputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">interp_values</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">Q</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
            <span class="n">inputs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">interp_values</span>
</pre></div>
</div>
<p>In this example, we use the adaptive sampler defined by
<code class="xref py py-class docutils literal notranslate"><span class="pre">rhoD_kernel</span></code>, which requires
an identification of a data distribution used to modify the transition
kernel for input samples. The idea is to place more samples in the
parameter space that correspond to a contour event of higher probability
as specified by the data distribution <code class="docutils literal notranslate"><span class="pre">rho_D</span></code> shown below.</p>
<p>First, we create the <code class="xref py py-mod docutils literal notranslate"><span class="pre">transition_set</span></code>
with an
initial step size ratio of 0.5 and a minimum, maximum step size ratio of
<code class="docutils literal notranslate"><span class="pre">.5**5</span></code> and 1.0 respectively. Note that this algorithm only generates
samples inside the parameter domain, <code class="docutils literal notranslate"><span class="pre">lam_domain</span></code> (see Step (2) below):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create Transition Kernel</span>
<span class="n">transition_set</span> <span class="o">=</span> <span class="n">asam</span><span class="o">.</span><span class="n">transition_set</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="o">**</span><span class="mi">5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we implicty designate a region of interest <span class="math notranslate nohighlight">\(\Lambda_k =
Q^{-1}(D_k)\)</span> in <span class="math notranslate nohighlight">\(\Lambda\)</span> for some <span class="math notranslate nohighlight">\(D_k \subset \mathcal{D}\)</span>
through the use of the data distribution kernel.
In this instance we choose our kernel
<span class="math notranslate nohighlight">\(p_k(Q) = \rho_\mathcal{D}(Q)\)</span>, see
<code class="xref py py-class docutils literal notranslate"><span class="pre">rhoD_kernel</span></code>.</p>
<p>We choose some <span class="math notranslate nohighlight">\(\lambda_{ref}\)</span> and
let <span class="math notranslate nohighlight">\(Q_{ref} = Q(\lambda_{ref})\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Q_ref</span> <span class="o">=</span> <span class="n">mdat</span><span class="p">[</span><span class="s1">&#39;Q_true&#39;</span><span class="p">]</span>
<span class="n">Q_ref</span> <span class="o">=</span> <span class="n">Q_ref</span><span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="n">station_nums</span><span class="p">]</span> <span class="c1"># 15th/20</span>
</pre></div>
</div>
<p>We define a 3-D box, <span class="math notranslate nohighlight">\(R_{ref} \subset \mathcal{D}\)</span> centered at
<span class="math notranslate nohighlight">\(Q(\lambda_{ref})\)</span> with sides 15% the length of <span class="math notranslate nohighlight">\(q_1\)</span>,
<span class="math notranslate nohighlight">\(q_5\)</span>, and <span class="math notranslate nohighlight">\(q_2\)</span>.
Set <span class="math notranslate nohighlight">\(\rho_\mathcal{D}(q) = \frac{\mathbf{1}_{R_{ref}}(q)}{||\mathbf{1}_{R_{ref}}||}\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bin_ratio</span> <span class="o">=</span> <span class="mf">0.15</span>
<span class="n">bin_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">*</span><span class="n">bin_ratio</span>
<span class="c1"># Create kernel</span>
<span class="n">maximum</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">bin_size</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rho_D</span><span class="p">(</span><span class="n">outputs</span><span class="p">):</span>
    <span class="n">rho_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">Q_ref</span><span class="o">-.</span><span class="mi">5</span><span class="o">*</span><span class="n">bin_size</span><span class="p">],</span> <span class="n">outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rho_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">Q_ref</span><span class="o">+.</span><span class="mi">5</span><span class="o">*</span><span class="n">bin_size</span><span class="p">],</span> <span class="n">outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rho_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">rho_left</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rho_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">rho_right</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">rho_left</span><span class="p">,</span> <span class="n">rho_right</span><span class="p">)</span>
    <span class="n">max_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">maximum</span><span class="p">,</span> <span class="n">outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inside</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">max_values</span>

<span class="n">kernel_rD</span> <span class="o">=</span> <span class="n">asam</span><span class="o">.</span><span class="n">rhoD_kernel</span><span class="p">(</span><span class="n">maximum</span><span class="p">,</span> <span class="n">rho_D</span><span class="p">)</span>
</pre></div>
</div>
<p>The basic idea is that when the region of interest has been âfoundâ by
some sample in a chain, the transition set is modified by the
adaptive sampler (it is made smaller) so that more samples are placed
within this event of interest.</p>
<p>Given a (M, mdim) data vector
<code class="xref py py-class docutils literal notranslate"><span class="pre">rhoD_kernel</span></code> expects that <code class="docutils literal notranslate"><span class="pre">rho_D</span></code>
will return a <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> of shape (M,).</p>
<p>Next, we create the <code class="xref py py-mod docutils literal notranslate"><span class="pre">sampler</span></code>. This
<code class="xref py py-mod docutils literal notranslate"><span class="pre">sampler</span></code> will create 80 independent
sampling chains that are each 125 samples long:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create sampler</span>
<span class="n">chain_length</span> <span class="o">=</span> <span class="mi">125</span>
<span class="n">num_chains</span> <span class="o">=</span> <span class="mi">80</span>
<span class="n">num_samples</span> <span class="o">=</span> <span class="n">chain_length</span><span class="o">*</span><span class="n">num_chains</span>
<span class="n">sampler</span> <span class="o">=</span> <span class="n">asam</span><span class="o">.</span><span class="n">sampler</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">chain_length</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>In the lines 54, 54 change <code class="docutils literal notranslate"><span class="pre">chain_length</span></code> and <code class="docutils literal notranslate"><span class="pre">num_chains</span></code> to
reduce the total number of forward solves.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">num_chains</span> <span class="pre">=</span> <span class="pre">1</span></code> above, then this is no longer a âbatchâ
sampling process where multiple chains are run simultaneously to
âsearch forâ the region of interest.</p></li>
<li><p>Saves to <code class="docutils literal notranslate"><span class="pre">sandbox2d.mat</span></code>.</p></li>
</ul>
</div>
</div>
<div class="section" id="step-2-and-step-3-describe-and-adaptively-sample-the-input-and-output-space">
<h3>Step (2) [and Step (3)]: Describe and (adaptively) sample the input (and output) space<a class="headerlink" href="#step-2-and-step-3-describe-and-adaptively-sample-the-input-and-output-space" title="Permalink to this headline">Â¶</a></h3>
<p>The adaptive sampling of the input space requires feedback from the
corresponding output samples, so the sets of samples are, in a sense,
created simultaneously in order to define the discretization of the
spaces used to solve the stochastic inverse problem.
While this can always be the case, in other examples, we often sampled the
input space completely in one step, and then propagated the samples
through the model to generate the QoI samples in another step, and
these two samples sets together were used to define the
discretization object used to solve the stochastic inverse problem.</p>
<p>The compact (bounded, finite-dimensional) paramter space for this
example is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lam_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">900</span><span class="p">,</span> <span class="mi">1500</span><span class="p">],</span> <span class="p">[</span><span class="o">.</span><span class="mi">07</span><span class="p">,</span> <span class="o">.</span><span class="mi">15</span><span class="p">],</span> <span class="p">[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">]])</span>
</pre></div>
</div>
<p>We choose an initial sample type to seed the sampling chains, which
in this case comes from using Latin-Hypercube sampling:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">inital_sample_type</span> <span class="o">=</span> <span class="s2">&quot;lhs&quot;</span>
</pre></div>
</div>
<p>Finally, we adaptively generate the samples using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">generalized_chains()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">my_disc</span><span class="p">,</span> <span class="n">all_step_ratios</span><span class="p">)</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">generalized_chains</span><span class="p">(</span><span class="n">lam_domain</span><span class="p">,</span>
    <span class="n">transition_set</span><span class="p">,</span> <span class="n">kernel_rD</span><span class="p">,</span> <span class="n">sample_save_file</span><span class="p">,</span> <span class="n">inital_sample_type</span><span class="p">)</span>
</pre></div>
</div>
<p>[OPTIONAL] We may choose to visualize the results by executing the
following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read in points_ref and plot results</span>
<span class="n">ref_sample</span> <span class="o">=</span> <span class="n">mdat</span><span class="p">[</span><span class="s1">&#39;points_true&#39;</span><span class="p">]</span>
<span class="n">ref_sample</span> <span class="o">=</span> <span class="n">ref_sample</span><span class="p">[:,</span> <span class="mi">14</span><span class="p">]</span>

<span class="c1"># Show the samples in the parameter space</span>
<span class="n">pDom</span><span class="o">.</span><span class="n">scatter_rhoD</span><span class="p">(</span><span class="n">my_disc</span><span class="p">,</span> <span class="n">rho_D</span><span class="o">=</span><span class="n">rho_D</span><span class="p">,</span> <span class="n">ref_sample</span><span class="o">=</span><span class="n">ref_sample</span><span class="p">,</span> <span class="n">io_flag</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
<span class="c1"># Show the corresponding samples in the data space</span>
<span class="n">pDom</span><span class="o">.</span><span class="n">scatter_rhoD</span><span class="p">(</span><span class="n">my_disc</span><span class="p">,</span> <span class="n">rho_D</span><span class="o">=</span><span class="n">rho_D</span><span class="p">,</span> <span class="n">ref_sample</span><span class="o">=</span><span class="n">Q_ref</span><span class="p">,</span> <span class="n">io_flag</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">)</span>
<span class="c1"># Show the data domain that corresponds with the convex hull of samples in the</span>
<span class="c1"># parameter space</span>
<span class="n">pDom</span><span class="o">.</span><span class="n">show_data_domain_2D</span><span class="p">(</span><span class="n">my_disc</span><span class="p">,</span> <span class="n">Q_ref</span><span class="o">=</span><span class="n">Q_ref</span><span class="p">)</span>

<span class="c1"># Show multiple data domains that correspond with the convex hull of samples in</span>
<span class="c1"># the parameter space</span>
<span class="n">pDom</span><span class="o">.</span><span class="n">show_data_domain_multi</span><span class="p">(</span><span class="n">my_disc</span><span class="p">,</span> <span class="n">Q_ref</span><span class="o">=</span><span class="n">Q_ref</span><span class="p">,</span> <span class="n">showdim</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The user could simply run the example <a class="reference external" href="https://github.com/UT-CHG/BET/tree/master/examples/fromFile_ADCIRCMap/plotDomains3D.py">plotDomains3D.py</a>
to see the results for a previously generated set of adaptive
samples.</p>
</div>
</div>
<div class="section" id="steps-4-5-user-defining-and-solving-a-stochastic-inverse-problem">
<h3>Steps (4)-(5) [user]: Defining and solving a stochastic inverse problem<a class="headerlink" href="#steps-4-5-user-defining-and-solving-a-stochastic-inverse-problem" title="Permalink to this headline">Â¶</a></h3>
<p>In the call to <code class="docutils literal notranslate"><span class="pre">sampler.generalized_chains</span></code> above, a discretization
object is created and saved. The user may wish to follow some of the other
examples (e.g., <a class="reference internal" href="linearMapUniformSampling.html#linearmap"><span class="std std-ref">Example: Linear Map with Uniform Sampling</span></a> or <a class="reference internal" href="nonlinearMapUniformSampling.html#nonlinearmap"><span class="std std-ref">Example: Nonlinear Map with Uniform Sampling</span></a>)
along with the paper referenced above to describe a data
distribution around a reference datum (Step (4)) and solve the stochastic
inverse problem (Step (5)) using the adaptively generated discretization
object by loading it from file. This can be done in a separate script
(but do not forget to do Step (0) which sets up the environment before
coding Steps (4) and (5)).</p>
</div>
</div>
<div class="section" id="generating-and-comparing-several-sets-of-adaptive-samples">
<h2>Generating and comparing several sets of adaptive samples<a class="headerlink" href="#generating-and-comparing-several-sets-of-adaptive-samples" title="Permalink to this headline">Â¶</a></h2>
<p>In some instances the user may want to generate and compare several sets of
adaptive samples using a surrogate model to determine what the best kernel,
transition set, number of generalized chains, and chain length are before
adaptively sampling a more computationally expensive model. See
<a class="reference external" href="https://github.com/UT-CHG/BET/tree/master/examples/fromFile_ADCIRCMap/sandbox_test_3D.py">sandbox_test_3D.py</a>.
The set up in
<a class="reference external" href="https://github.com/UT-CHG/BET/tree/master/examples/fromFile_ADCIRCMap/sandbox_test_3D.py">sandbox_test_3D.py</a>
is very similar to the
set up in <a class="reference external" href="https://github.com/UT-CHG/BET/tree/master/examples/fromFile_ADCIRCMap/fromFile3D.py">fromFile3D</a>
and is
omitted for brevity.</p>
<p>We can explore several types of kernels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kernel_mm</span> <span class="o">=</span> <span class="n">asam</span><span class="o">.</span><span class="n">maxima_mean_kernel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Q_ref</span><span class="p">]),</span> <span class="n">rho_D</span><span class="p">)</span>
<span class="n">kernel_m</span> <span class="o">=</span> <span class="n">asam</span><span class="o">.</span><span class="n">maxima_kernel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Q_ref</span><span class="p">]),</span> <span class="n">rho_D</span><span class="p">)</span>
<span class="n">kernel_rD</span> <span class="o">=</span> <span class="n">asam</span><span class="o">.</span><span class="n">rhoD_kernel</span><span class="p">(</span><span class="n">maximum</span><span class="p">,</span> <span class="n">rho_D</span><span class="p">)</span>
<span class="n">kern_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">kernel_mm</span><span class="p">,</span> <span class="n">kernel_rD</span><span class="p">,</span> <span class="n">kernel_m</span><span class="p">]</span>
<span class="c1"># Get samples</span>
<span class="c1"># Run with varying kernels</span>
<span class="n">gen_results</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run_gen</span><span class="p">(</span><span class="n">kern_list</span><span class="p">,</span> <span class="n">rho_D</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">param_min</span><span class="p">,</span>
        <span class="n">param_max</span><span class="p">,</span> <span class="n">transition_set</span><span class="p">,</span> <span class="n">sample_save_file</span><span class="p">)</span>
</pre></div>
</div>
<p>We can explore <code class="xref py py-class docutils literal notranslate"><span class="pre">transition_set</span></code> with
various inital, minimum, and maximum step size ratios:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run with varying transition sets bounds</span>
<span class="n">init_ratio</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
<span class="n">min_ratio</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2e-3</span><span class="p">,</span> <span class="mf">2e-5</span><span class="p">,</span> <span class="mf">2e-8</span><span class="p">]</span>
<span class="n">max_ratio</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="n">tk_results</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run_tk</span><span class="p">(</span><span class="n">init_ratio</span><span class="p">,</span> <span class="n">min_ratio</span><span class="p">,</span> <span class="n">max_ratio</span><span class="p">,</span> <span class="n">rho_D</span><span class="p">,</span>
        <span class="n">maximum</span><span class="p">,</span> <span class="n">param_min</span><span class="p">,</span> <span class="n">param_max</span><span class="p">,</span> <span class="n">kernel_rD</span><span class="p">,</span> <span class="n">sample_save_file</span><span class="p">)</span>
</pre></div>
</div>
<p>We can explore a single kernel with varying values of ratios for increasing
and decreasing the step size (i.e. the size of the hyperrectangle to draw a new
step from using a transition set):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">increase</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]</span>
<span class="n">decrease</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5e2</span><span class="p">,</span> <span class="mf">0.5e3</span><span class="p">]</span>
<span class="n">tolerance</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-4</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">]</span>
<span class="n">incdec_results</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run_inc_dec</span><span class="p">(</span><span class="n">increase</span><span class="p">,</span> <span class="n">decrease</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">rho_D</span><span class="p">,</span>
    <span class="n">maximum</span><span class="p">,</span> <span class="n">param_min</span><span class="p">,</span> <span class="n">param_max</span><span class="p">,</span> <span class="n">transition_set</span><span class="p">,</span> <span class="n">sample_save_file</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above examples just use a <code class="docutils literal notranslate"><span class="pre">zip</span></code> combination of the lists uses to
define varying parameters for the kernels and transition sets. To explore
the product of these lists you need to use <code class="docutils literal notranslate"><span class="pre">numpy.meshgrid</span></code> and
<code class="docutils literal notranslate"><span class="pre">numpy.ravel</span></code> or a similar process.</p>
</div>
<p>To compare the results in terms of yield or the total number of samples
generated in the region of interest we can use
<code class="xref py py-class docutils literal notranslate"><span class="pre">compare_yield</span></code> to display the results to screen:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compare the quality of several sets of samples</span>
<span class="nb">print</span> <span class="s2">&quot;Compare yield of sample sets with various kernels&quot;</span>
<span class="n">bsam</span><span class="o">.</span><span class="n">compare_yield</span><span class="p">(</span><span class="n">gen_results</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">gen_results</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">gen_results</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="nb">print</span> <span class="s2">&quot;Compare yield of sample sets with various transition sets bounds&quot;</span>
<span class="n">bsam</span><span class="o">.</span><span class="n">compare_yield</span><span class="p">(</span><span class="n">tk_results</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">tk_results</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">tk_results</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="nb">print</span> <span class="s2">&quot;Compare yield of sample sets with variouos increase/decrease ratios&quot;</span>
<span class="n">bsam</span><span class="o">.</span><span class="n">compare_yield</span><span class="p">(</span><span class="n">incdec_results</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">incdec_results</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">incdec_results</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
<p>Here <code class="xref py py-meth docutils literal notranslate"><span class="pre">compare_yield()</span></code> simply displays to screen the
<code class="docutils literal notranslate"><span class="pre">sample_quality</span></code> and <code class="docutils literal notranslate"><span class="pre">run_param</span></code> sorted by <code class="docutils literal notranslate"><span class="pre">sample_quality</span></code> and indexed
by <code class="docutils literal notranslate"><span class="pre">sort_ind</span></code>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="linearMapUniformSampling.html" class="btn btn-neutral float-right" title="Example: Linear Map with Uniform Sampling" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="fromfile2D.html" class="btn btn-neutral float-left" title="Example: Batch Adaptive Sampling (2-to-2 example)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, The BET Development Team (Lindley Graham, Steven Mattis, Troy Butler, Scott Walsh, Michael Pilosov)
      <span class="lastupdated">
        Last updated on Jul 30, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>