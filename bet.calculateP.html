

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>bet.calculateP package &mdash; BET 2.0.0-beta documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="BET 2.0.0-beta documentation" href="index.html"/>
        <link rel="up" title="bet package" href="bet.html"/>
        <link rel="next" title="bet.postProcess package" href="bet.postProcess.html"/>
        <link rel="prev" title="bet package" href="bet.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> BET
          

          
          </a>

          
            
            
              <div class="version">
                2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel.html">Parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/examples_overview.html">Some References and Examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">bet</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="bet.html">bet package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="bet.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">bet.calculateP package</a></li>
<li class="toctree-l4"><a class="reference internal" href="bet.postProcess.html">bet.postProcess package</a></li>
<li class="toctree-l4"><a class="reference internal" href="bet.sampling.html">bet.sampling package</a></li>
<li class="toctree-l4"><a class="reference internal" href="bet.sensitivity.html">bet.sensitivity package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="bet.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="bet.html#module-bet.Comm">bet.Comm module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bet.html#module-bet.sample">bet.sample module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bet.html#module-bet.util">bet.util module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bet.html#module-contents">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="todo_list.html">Todo List</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">BET</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="modules.html">bet</a> &raquo;</li>
      
          <li><a href="bet.html">bet package</a> &raquo;</li>
      
    <li>bet.calculateP package</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/bet.calculateP.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="bet-calculatep-package">
<h1>bet.calculateP package<a class="headerlink" href="#bet-calculatep-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-bet.calculateP.calculateP">
<span id="bet-calculatep-calculatep-module"></span><h2>bet.calculateP.calculateP module<a class="headerlink" href="#module-bet.calculateP.calculateP" title="Permalink to this headline">¶</a></h2>
<p>This module provides methods for calulating the probability measure
<span class="math">\(P_{\Lambda}\)</span>.</p>
<ul>
<li><dl class="first docutils">
<dt><code class="xref py py-mod docutils literal"><span class="pre">prob_emulated</span></code> provides a skeleton class and calculates</dt>
<dd><p class="first last">the probability for a set of emulation points.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="xref py py-mod docutils literal"><span class="pre">prob_samples_mc</span></code> estimates the </dt>
<dd><p class="first last">probability based on pre-defined volumes.</p>
</dd>
</dl>
</li>
</ul>
<dl class="function">
<dt id="bet.calculateP.calculateP.prob">
<code class="descclassname">bet.calculateP.calculateP.</code><code class="descname">prob</code><span class="sig-paren">(</span><em>discretization</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math">\(P_{\Lambda}(\mathcal{V}_{\lambda_{samples}})\)</span>, the
probability assoicated with a set of  cells defined by the model
solves at <span class="math">\((\lambda_{samples})\)</span> where the volumes of these 
cells are provided.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>discretization</strong> (class:<cite>bet.sample.discretization</cite>) &#8211; An object containing the discretization information.</li>
<li><strong>globalize</strong> (<em>bool</em>) &#8211; Makes local variables global.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.calculateP.prob_on_emulated_samples">
<code class="descclassname">bet.calculateP.calculateP.</code><code class="descname">prob_on_emulated_samples</code><span class="sig-paren">(</span><em>discretization</em>, <em>globalize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob_on_emulated_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math">\(P_{\Lambda}(\mathcal{V}_{\lambda_{emulate}})\)</span>, the
probability assoicated with a set of voronoi cells defined by
<code class="docutils literal"><span class="pre">num_l_emulate</span></code> iid samples <span class="math">\((\lambda_{emulate})\)</span>.
This is added to the emulated input sample set object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>discretization</strong> (class:<cite>bet.sample.discretization</cite>) &#8211; An object containing the discretization information.</li>
<li><strong>globalize</strong> (<em>bool</em>) &#8211; Makes local variables global.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.calculateP.prob_with_emulated_volumes">
<code class="descclassname">bet.calculateP.calculateP.</code><code class="descname">prob_with_emulated_volumes</code><span class="sig-paren">(</span><em>discretization</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob_with_emulated_volumes" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math">\(P_{\Lambda}(\mathcal{V}_{\lambda_{samples}})\)</span>, the
probability associated with a set of  cells defined by the model
solves at <span class="math">\((\lambda_{samples})\)</span> where the volumes are calculated
with the given emulated input points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>discretization</strong> (class:<cite>bet.sample.discretization</cite>) &#8211; An object containing the discretization information.</li>
<li><strong>globalize</strong> &#8211; Makes local variables global.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-bet.calculateP.indicatorFunctions">
<span id="bet-calculatep-indicatorfunctions-module"></span><h2>bet.calculateP.indicatorFunctions module<a class="headerlink" href="#module-bet.calculateP.indicatorFunctions" title="Permalink to this headline">¶</a></h2>
<p>This module provides various indicator functions, <span class="math">\(\mathbf{1}_A\)</span> for
various sets <span class="math">\(A \subset \mathbb{R}^n\)</span> where given a set of points in
<span class="math">\(\{x_i\}_{i=0}^{N} \in \mathbf{R}^n\)</span> returns <span class="math">\(\{ \mathbf{1}_A(x_i)
\}_{i=0}^{N}\)</span>.</p>
<dl class="function">
<dt id="bet.calculateP.indicatorFunctions.boundary_hyperrectangle">
<code class="descclassname">bet.calculateP.indicatorFunctions.</code><code class="descname">boundary_hyperrectangle</code><span class="sig-paren">(</span><em>left</em>, <em>right</em>, <em>boundary_width</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.indicatorFunctions.boundary_hyperrectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointwise indicator function for the set of points within
<code class="docutils literal"><span class="pre">boundary_width</span></code> of the boundary of a hyperrectangle defined by a
leftmost and rightmost corner.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; Leftmost(minimum) corner of the hyperrectangle.</li>
<li><strong>right</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; Rightmost(maximum) corner of the hyperrectangle.</li>
<li><strong>boundary_width</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; Width of the boundary</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">function</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><span class="math">\(\mathbf{1}_{\partial A \plusminus \epsilon}\)</span></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.indicatorFunctions.boundary_hyperrectangle_ratio">
<code class="descclassname">bet.calculateP.indicatorFunctions.</code><code class="descname">boundary_hyperrectangle_ratio</code><span class="sig-paren">(</span><em>left</em>, <em>right</em>, <em>boundary_ratio</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.indicatorFunctions.boundary_hyperrectangle_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointwise indicator function for the set of points within
<code class="docutils literal"><span class="pre">boundary_ratio*hyperrectanlge_width</span></code> of the boundary of a hyperrectangle
defined by a leftmost and rightmost corner.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; Leftmost(minimum) corner of the hyperrectangle.</li>
<li><strong>right</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; Rightmost(maximum) corner of the hyperrectangle.</li>
<li><strong>boundary_ratio</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; Ratio of the width of the boundary</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">function</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><span class="math">\(\mathbf{1}_{\partial A \plusminus \epsilon}\)</span></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.indicatorFunctions.boundary_hyperrectangle_size">
<code class="descclassname">bet.calculateP.indicatorFunctions.</code><code class="descname">boundary_hyperrectangle_size</code><span class="sig-paren">(</span><em>center</em>, <em>width</em>, <em>boundary_width</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.indicatorFunctions.boundary_hyperrectangle_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointwise indicator function for the set of points within
<code class="docutils literal"><span class="pre">boundary_width</span></code> of the boundary of  a hyperrectangle defined by a center
point and the width of the hyperrectangle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; center of the hyperrectangle.</li>
<li><strong>width</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; length of the size of the sides of the hyperrectangle.</li>
<li><strong>boundary_width</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; Width of the boundary</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">function</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><span class="math">\(\mathbf{1}_{\partial A \plusminus \epsilon}\)</span></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.indicatorFunctions.boundary_hyperrectangle_size_ratio">
<code class="descclassname">bet.calculateP.indicatorFunctions.</code><code class="descname">boundary_hyperrectangle_size_ratio</code><span class="sig-paren">(</span><em>center</em>, <em>width</em>, <em>boundary_ratio</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.indicatorFunctions.boundary_hyperrectangle_size_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointwise indicator function for the set of points within
<code class="docutils literal"><span class="pre">boundary_ratio*hyperrectanlge_width</span></code> of the boundary of  a
hyperrectangle defined by a center point and the width of the
hyperrectangle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; center of the hyperrectangle.</li>
<li><strong>width</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; length of the size of the sides of the hyperrectangle.</li>
<li><strong>boundary_ratio</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; Ratio of the width of the boundary</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">function</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><span class="math">\(\mathbf{1}_{\partial A \plusminus \epsilon}\)</span></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.indicatorFunctions.boundary_hypersphere">
<code class="descclassname">bet.calculateP.indicatorFunctions.</code><code class="descname">boundary_hypersphere</code><span class="sig-paren">(</span><em>center</em>, <em>radius</em>, <em>boundary_width</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.indicatorFunctions.boundary_hypersphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointwise indicator function for a hypersphere defined by a center and a
radius.</p>
<p>If radius is a vector and not a scalar this will work for an hyperellipse.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (ndim,)) &#8211; center of the hypersphere/ellipse</li>
<li><strong>radius</strong> (<code class="docutils literal"><span class="pre">float</span></code> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape(ndim,)) &#8211; radius or radii of the hypereliipse</li>
<li><strong>boundary_width</strong> &#8211; Width of the boundary</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">callable</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><span class="math">\(\mathbf{1}_A\)</span> where A is a hypersphere/ellipse</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.indicatorFunctions.boundary_hypersphere_ratio">
<code class="descclassname">bet.calculateP.indicatorFunctions.</code><code class="descname">boundary_hypersphere_ratio</code><span class="sig-paren">(</span><em>center</em>, <em>radius</em>, <em>boundary_ratio</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.indicatorFunctions.boundary_hypersphere_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointwise indicator function for a hypersphere defined by a center and a
radius.</p>
<p>If radius is a vector and not a scalar this will work for an hyperellipse.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (ndim,)) &#8211; center of the hypersphere/ellipse</li>
<li><strong>radius</strong> (<code class="docutils literal"><span class="pre">float</span></code> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape(ndim,)) &#8211; radius or radii of the hypereliipse</li>
<li><strong>boundary_ratio</strong> &#8211; Ratio of the width of the boundary</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">callable</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><span class="math">\(\mathbf{1}_A\)</span> where A is a hypersphere/ellipse</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.indicatorFunctions.hyperrectangle">
<code class="descclassname">bet.calculateP.indicatorFunctions.</code><code class="descname">hyperrectangle</code><span class="sig-paren">(</span><em>left</em>, <em>right</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.indicatorFunctions.hyperrectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointwise indicator function for a hyperrectangle defined by a leftmost and
rightmost corner.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; Leftmost(minimum) corner of the hyperrectangle.</li>
<li><strong>right</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; Rightmost(maximum) corner of the hyperrectangle.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">function</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><span class="math">\(\mathbf{1}_A\)</span></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.indicatorFunctions.hyperrectangle_size">
<code class="descclassname">bet.calculateP.indicatorFunctions.</code><code class="descname">hyperrectangle_size</code><span class="sig-paren">(</span><em>center</em>, <em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.indicatorFunctions.hyperrectangle_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointwise indicator function for a hyperrectangle defined by a center point
and the width of the hyperrectangle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; center of the hyperrectangle.</li>
<li><strong>width</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (ndim,)) &#8211; length of the size of the sides of the hyperrectangle.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">function</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><span class="math">\(\mathbf{1}_A\)</span></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.indicatorFunctions.hypersphere">
<code class="descclassname">bet.calculateP.indicatorFunctions.</code><code class="descname">hypersphere</code><span class="sig-paren">(</span><em>center</em>, <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.indicatorFunctions.hypersphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointwise indicator function for a hypersphere defined by a center and a
radius.</p>
<p>If radius is a vector and not a scalar this will work for an hyperellipse.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (ndim,)) &#8211; center of the hypersphere/ellipse</li>
<li><strong>radius</strong> (<code class="docutils literal"><span class="pre">float</span></code> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape(ndim,)) &#8211; radius or radii of the hypereliipse</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">callable</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><span class="math">\(\mathbf{1}_A\)</span> where A is a hypersphere/ellipse</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-bet.calculateP.simpleFunP">
<span id="bet-calculatep-simplefunp-module"></span><h2>bet.calculateP.simpleFunP module<a class="headerlink" href="#module-bet.calculateP.simpleFunP" title="Permalink to this headline">¶</a></h2>
<p>This module provides methods for creating simple function approximations to be
used by <a class="reference internal" href="#module-bet.calculateP.calculateP" title="bet.calculateP.calculateP"><code class="xref py py-mod docutils literal"><span class="pre">calculateP</span></code></a>. These simple function approximations
are returned as <cite>bet.sample.sample_set</cite> objects.</p>
<dl class="function">
<dt id="bet.calculateP.simpleFunP.normal_partition_normal_distribution">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">normal_partition_normal_distribution</code><span class="sig-paren">(</span><em>data_set</em>, <em>Q_ref</em>, <em>std</em>, <em>M</em>, <em>num_d_emulate=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.normal_partition_normal_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a multivariate normal probability
density centered at <code class="docutils literal"><span class="pre">Q_ref</span></code> with standard deviation <code class="docutils literal"><span class="pre">std</span></code> using
<code class="docutils literal"><span class="pre">M</span></code> bins sampled from the given normal distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>) &#8211; Sample set that the probability measure is defined for.</li>
<li><strong>M</strong> (<em>int</em>) &#8211; Defines number M samples in D used to define
<span class="math">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an &#8220;art&#8221; -
play around with it and you can get reasonable results with a
relatively small number here like 50.</li>
<li><strong>num_d_emulate</strong> (<em>int</em>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\lambda_{reference})\)</span></li>
<li><strong>std</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; The standard deviation of each QoI</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal"><span class="pre">voronoi_sample_set</span></code></a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sample_set object defining simple function approximation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.regular_partition_uniform_distribution_rectangle_domain">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">regular_partition_uniform_distribution_rectangle_domain</code><span class="sig-paren">(</span><em>data_set</em>, <em>rect_domain</em>, <em>center_pts_per_edge=1</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.regular_partition_uniform_distribution_rectangle_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function appoximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho{\mathcal{D}, M}\)</span> is a uniform probablity density over the
hyperrectangular domain specified by <code class="docutils literal"><span class="pre">rect_domain</span></code>.</p>
<p>Since <span class="math">\(\rho_\mathcal{D}\)</span> is a uniform distribution on a
hyperrectangle we should we able to represent it exactly with
<span class="math">\(M=3^{m}\)</span> where m is the dimension of the data space or rather
<code class="docutils literal"><span class="pre">len(d_distr_samples)</span> <span class="pre">==</span> <span class="pre">3**mdim</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>) &#8211; Sample set that the probability measure is defined for.</li>
<li><strong>rect_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (2, mdim)) &#8211; The domain overwhich <span class="math">\(\rho_\mathcal{D}\)</span> is
uniform.</li>
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal"><span class="pre">voronoi_sample_set</span></code></a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sample_set object defininng simple function approximation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.regular_partition_uniform_distribution_rectangle_scaled">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">regular_partition_uniform_distribution_rectangle_scaled</code><span class="sig-paren">(</span><em>data_set</em>, <em>Q_ref</em>, <em>rect_scale</em>, <em>center_pts_per_edge=1</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.regular_partition_uniform_distribution_rectangle_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a uniform probability density
centered at <code class="docutils literal"><span class="pre">Q_ref</span></code> with <code class="docutils literal"><span class="pre">rect_scale</span></code> of the width
of D.</p>
<p>Since rho_D is a uniform distribution on a hyperrectanlge we should be able
to represent it exactly with <code class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">3^mdim</span></code> or rather
<code class="docutils literal"><span class="pre">len(d_distr_samples)</span> <span class="pre">==</span> <span class="pre">3^mdim</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>) &#8211; Sample set that the probability measure is defined for.</li>
<li><strong>rect_scale</strong> (<em>double or list()</em>) &#8211; The scale used to determine the width of the
uniform distributiion as <code class="docutils literal"><span class="pre">rect_size</span> <span class="pre">=</span> <span class="pre">(data_max-data_min)*rect_scale</span></code></li>
<li><strong>num_d_emulate</strong> (<em>int</em>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\lambda_{reference})\)</span></li>
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal"><span class="pre">voronoi_sample_set</span></code></a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sample_set object defininng simple function approximation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.regular_partition_uniform_distribution_rectangle_size">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">regular_partition_uniform_distribution_rectangle_size</code><span class="sig-paren">(</span><em>data_set</em>, <em>Q_ref</em>, <em>rect_size</em>, <em>center_pts_per_edge=1</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.regular_partition_uniform_distribution_rectangle_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a uniform probability density
centered at <code class="docutils literal"><span class="pre">Q_ref</span></code> with <code class="docutils literal"><span class="pre">rect_size</span></code> of the width of a hyperrectangle.</p>
<p>Since rho_D is a uniform distribution on a hyperrectanlge we should be able
to represent it exactly with <code class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">3^mdim</span></code> or rather
<code class="docutils literal"><span class="pre">len(d_distr_samples)</span> <span class="pre">==</span> <span class="pre">3^mdim</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rect_size</strong> (<em>double or list()</em>) &#8211; The size used to determine the width of the uniform
distribution</li>
<li><strong>num_d_emulate</strong> (<em>int</em>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>) &#8211; Sample set that the probability measure is defined for.</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\lambda_{reference})\)</span></li>
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge
and additional two points will be added to create the bounding layer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal"><span class="pre">voronoi_sample_set</span></code></a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sample_set object defininng simple function approximation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.uniform_partition_normal_distribution">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">uniform_partition_normal_distribution</code><span class="sig-paren">(</span><em>data_set</em>, <em>Q_ref</em>, <em>std</em>, <em>M</em>, <em>num_d_emulate=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_partition_normal_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a multivariate normal probability
density centered at <code class="docutils literal"><span class="pre">Q_ref</span></code> with standard deviation <code class="docutils literal"><span class="pre">std</span></code> using
<code class="docutils literal"><span class="pre">M</span></code> bins sampled from a uniform distribution with a size 4 standard
deviations in each direction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>) &#8211; Sample set that the probability measure is defined for.</li>
<li><strong>M</strong> (<em>int</em>) &#8211; Defines number M samples in D used to define
<span class="math">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an &#8220;art&#8221; -
play around with it and you can get reasonable results with a
relatively small number here like 50.</li>
<li><strong>num_d_emulate</strong> (<em>int</em>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\lambda_{reference})\)</span></li>
<li><strong>std</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; The standard deviation of each QoI</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal"><span class="pre">voronoi_sample_set</span></code></a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sample_set object defininng simple function approximation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_data_samples">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">uniform_partition_uniform_distribution_data_samples</code><span class="sig-paren">(</span><em>data_set</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_data_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a uniform probability density over
the entire <code class="docutils literal"><span class="pre">data_domain</span></code>. Here the <code class="docutils literal"><span class="pre">data_domain</span></code> is the union of
voronoi cells defined by <code class="docutils literal"><span class="pre">data</span></code>. In other words we assign each sample the
same probability, so <code class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">len(data)</span></code> or rather <code class="docutils literal"><span class="pre">len(d_distr_samples)</span> <span class="pre">==</span>
<span class="pre">len(data)</span></code>. The purpose of this method is to approximate uniform
distributions over irregularly shaped domains.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal"><span class="pre">discretization</span></code></a> 
or <a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>) &#8211; Sample set that the probability measure is defined for.</li>
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal"><span class="pre">voronoi_sample_set</span></code></a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sample_set object defininng simple function approximation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_rectangle_domain">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">uniform_partition_uniform_distribution_rectangle_domain</code><span class="sig-paren">(</span><em>data_set</em>, <em>rect_domain</em>, <em>M=50</em>, <em>num_d_emulate=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_rectangle_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D}}\)</span>
where <span class="math">\(\rho_{\mathcal{D}}\)</span> is a uniform probability density on
a generalized rectangle defined by <code class="docutils literal"><span class="pre">rect_domain</span></code>.
The simple function approximation is then defined by determining <code class="docutils literal"><span class="pre">M</span></code>
Voronoi cells (i.e., &#8220;bins&#8221;) partitioning <span class="math">\(\mathcal{D}\)</span>. These
bins are only implicitly defined by <code class="docutils literal"><span class="pre">M</span> <span class="pre">``samples</span> <span class="pre">in</span> <span class="pre">:math:`\mathcal{D}`.</span>
<span class="pre">Finally,</span> <span class="pre">the</span> <span class="pre">probabilities</span> <span class="pre">of</span> <span class="pre">each</span> <span class="pre">of</span> <span class="pre">these</span> <span class="pre">bins</span> <span class="pre">is</span> <span class="pre">computed</span> <span class="pre">by</span>
<span class="pre">sampling</span> <span class="pre">from</span> <span class="pre">:math:`\rho{\mathcal{D}}`</span> <span class="pre">and</span> <span class="pre">using</span> <span class="pre">nearest</span> <span class="pre">neighbor</span>
<span class="pre">searches</span> <span class="pre">to</span> <span class="pre">bin</span> <span class="pre">these</span> <span class="pre">samples</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">``M</span></code> implicitly defined bins.
The result is the simple function approximation denoted by
<span class="math">\(\rho_{\mathcal{D},M}\)</span>.</p>
<p>Note that all computations in the measure-theoretic framework that
follow from this are for the fixed simple function approximation
<span class="math">\(\rho_{\mathcal{D},M}\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>M</strong> (<em>int</em>) &#8211; Defines number M samples in D used to define
<span class="math">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an &#8220;art&#8221; -
play around with it and you can get reasonable results with a
relatively small number here like 50.</li>
<li><strong>rect_domain</strong> (<em>double or list()</em>) &#8211; The support of the density</li>
<li><strong>num_d_emulate</strong> (<em>int</em>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>) &#8211; Sample set that the probability measure is defined for.</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\)</span>lambda_{reference})`</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal"><span class="pre">voronoi_sample_set</span></code></a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sample_set object defininng simple function approximation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_rectangle_scaled">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">uniform_partition_uniform_distribution_rectangle_scaled</code><span class="sig-paren">(</span><em>data_set</em>, <em>Q_ref</em>, <em>rect_scale=0.2</em>, <em>M=50</em>, <em>num_d_emulate=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_rectangle_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D}}\)</span>
where <span class="math">\(\rho_{\mathcal{D}}\)</span> is a uniform probability density on
a generalized rectangle centered at <code class="docutils literal"><span class="pre">Q_ref</span></code>.
The support of this density is defined by <code class="docutils literal"><span class="pre">rect_scale</span></code>, which determines
the size of the generalized rectangle by scaling the circumscribing 
generalized rectangle of <span class="math">\(\mathcal{D}\)</span>.
The simple function approximation is then defined by determining <code class="docutils literal"><span class="pre">M</span> <span class="pre">``</span>
<span class="pre">Voronoi</span> <span class="pre">cells</span> <span class="pre">(i.e.,</span> <span class="pre">&quot;bins&quot;)</span> <span class="pre">partitioning</span> <span class="pre">:math:`\mathcal{D}`.</span> <span class="pre">These</span>
<span class="pre">bins</span> <span class="pre">are</span> <span class="pre">only</span> <span class="pre">implicitly</span> <span class="pre">defined</span> <span class="pre">by</span> <span class="pre">``M</span></code> samples in <span class="math">\(\mathcal{D}\)</span>.
Finally, the probabilities of each of these bins is computed by 
sampling from <span class="math">\(\rho{\mathcal{D}}\)</span> and using nearest neighbor 
searches to bin these samples in the <code class="docutils literal"><span class="pre">M</span></code> implicitly defined bins.
The result is the simple function approximation denoted by
<span class="math">\(\rho_{\mathcal{D},M}\)</span>.</p>
<p>Note that all computations in the measure-theoretic framework that
follow from this are for the fixed simple function approximation
<span class="math">\(\rho_{\mathcal{D},M}\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>M</strong> (<em>int</em>) &#8211; Defines number M samples in D used to define
<span class="math">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an &#8220;art&#8221; -
play around with it and you can get reasonable results with a
relatively small number here like 50.</li>
<li><strong>rect_scale</strong> (<em>double or list()</em>) &#8211; The scale used to determine the support of the
uniform distribution as <code class="docutils literal"><span class="pre">rect_size</span> <span class="pre">=</span> <span class="pre">(data_max-data_min)*rect_scale</span></code></li>
<li><strong>num_d_emulate</strong> (<em>int</em>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>) &#8211; Sample set that the probability measure is defined for.</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\)</span>lambda_{reference})`</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal"><span class="pre">voronoi_sample_set</span></code></a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sample_set object defininng simple function approximation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_rectangle_size">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">uniform_partition_uniform_distribution_rectangle_size</code><span class="sig-paren">(</span><em>data_set</em>, <em>Q_ref</em>, <em>rect_size</em>, <em>M=50</em>, <em>num_d_emulate=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_rectangle_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D}}\)</span>
where <span class="math">\(\rho_{\mathcal{D}}\)</span> is a uniform probability density on
a generalized rectangle centered at <code class="docutils literal"><span class="pre">Q_ref</span></code>.
The support of this density is defined by <code class="docutils literal"><span class="pre">rect_size</span></code>, which determines
the size of the generalized rectangle.
The simple function approximation is then defined by determining <code class="docutils literal"><span class="pre">M</span></code>
Voronoi cells (i.e., &#8220;bins&#8221;) partitioning <span class="math">\(\mathcal{D}\)</span>. These
bins are only implicitly defined by <code class="docutils literal"><span class="pre">M</span></code> samples in <span class="math">\(\mathcal{D}\)</span>.
Finally, the probabilities of each of these bins is computed by
sampling from <span class="math">\(\rho{\mathcal{D}}\)</span> and using nearest neighbor
searches to bin these samples in the <code class="docutils literal"><span class="pre">M</span></code> implicitly defined bins.
The result is the simple function approximation denoted by
<span class="math">\(\rho_{\mathcal{D},M}\)</span>.</p>
<p>Note that all computations in the measure-theoretic framework that
follow from this are for the fixed simple function approximation
<span class="math">\(\rho_{\mathcal{D},M}\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>M</strong> (<em>int</em>) &#8211; Defines number M samples in D used to define
<span class="math">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an &#8220;art&#8221; -
play around with it and you can get reasonable results with a
relatively small number here like 50.</li>
<li><strong>rect_size</strong> (<em>double or list()</em>) &#8211; Determines the size of the support of the
uniform distribution on a generalized rectangle</li>
<li><strong>num_d_emulate</strong> (<em>int</em>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal"><span class="pre">discretization</span></code></a> 
or <a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>) &#8211; Sample set that the probability measure is defined for.</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\)</span>lambda_{reference})`</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal"><span class="pre">voronoi_sample_set</span></code></a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sample_set object defininng simple function approximation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.user_partition_user_distribution">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">user_partition_user_distribution</code><span class="sig-paren">(</span><em>data_set</em>, <em>data_partition_set</em>, <em>data_distribution_set</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.user_partition_user_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a user defined simple function approximation of a user
defined distribution. The simple function discretization is
specified in the <code class="docutils literal"><span class="pre">data_partition_set</span></code>, and the set of i.i.d.
samples from the distribution is specified in the
<code class="docutils literal"><span class="pre">data_distribution_set</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>) &#8211; Sample set that the probability measure is defined for.</li>
<li><strong>data_partition_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>) &#8211; Sample set defining the discretization
of the data space into Voronoi cells for which a simple function
is defined upon.</li>
<li><strong>data_distribution_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>) &#8211; Sample set containing the i.i.d. samples
from the distribution on the data space that are binned within the
Voronoi cells implicitly defined by the data_discretization_set.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal"><span class="pre">voronoi_sample_set</span></code></a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sample_set object defininng simple function approximation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="exception">
<dt id="bet.calculateP.simpleFunP.wrong_argument_type">
<em class="property">exception </em><code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">wrong_argument_type</code><a class="headerlink" href="#bet.calculateP.simpleFunP.wrong_argument_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Exception for when the argument for data_set is not one of the acceptible
types.</p>
</dd></dl>

</div>
<div class="section" id="module-bet.calculateP.voronoiHistogram">
<span id="bet-calculatep-voronoihistogram-module"></span><h2>bet.calculateP.voronoiHistogram module<a class="headerlink" href="#module-bet.calculateP.voronoiHistogram" title="Permalink to this headline">¶</a></h2>
<p>This module provides methods for creating the edges and generating point for
regular (hyperrectangle) multidimensional voronoi cells and for determining the
volumes of these cells.</p>
<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.center_and_layer1_points">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">center_and_layer1_points</code><span class="sig-paren">(</span><em>center_pts_per_edge</em>, <em>center</em>, <em>r_ratio</em>, <em>sur_domain</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.center_and_layer1_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a regular grid of center points that define the voronoi
tesselation of exactly the interior of a hyperrectangle centered at
<code class="docutils literal"><span class="pre">center</span></code> with sides of length <code class="docutils literal"><span class="pre">r_ratio*sur_width</span></code> and the layers
of voronoi cells that bound these interior cells. The resulting voronoi
tesselation exactly represents the hyperrectangle.</p>
<p>This method can also be used to tile <code class="docutils literal"><span class="pre">sur_domain</span></code> with points to define
voronoi regions if the user sets <code class="docutils literal"><span class="pre">r_ratio</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
<li><strong>center</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim,)) &#8211; location of the center of the hyperrectangle</li>
<li><strong>r_ratio</strong> (<em>double or list()</em>) &#8211; ratio of the length of the sides of the
hyperrectangle rect_domain to definie voronoi cells for</li>
<li><strong>sur_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; minima and maxima of each dimension defining the
surrounding domain. The surrounding domain is the bounded domain
in the data space (i.e. the data domain).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">tuple</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(points, interior_and_layer1, rect_domain) where where points is
an <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (num_points, dim),
interior_and_layer1 is a list() of dim <code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray`s</span> <span class="pre">of</span> <span class="pre">shape</span>
<span class="pre">(center_pts_per_edge+2,),</span> <span class="pre">rect_domain</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">:class:`numpy.ndarray</span></code> of
shape (mdim, 2).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.center_and_layer1_points_binsize">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">center_and_layer1_points_binsize</code><span class="sig-paren">(</span><em>center_pts_per_edge</em>, <em>center</em>, <em>r_size</em>, <em>sur_domain</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.center_and_layer1_points_binsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a regular grid of center points that define the voronoi
tesselation of exactly the interior of a hyperrectangle centered at
<code class="docutils literal"><span class="pre">center</span></code> with sides of length <code class="docutils literal"><span class="pre">r_size</span></code> and the layers
of voronoi cells that bound these interior cells. The resulting voronoi
tesselation exactly represents the hyperrectangle.</p>
<p>This method can also be used to tile <code class="docutils literal"><span class="pre">sur_domain</span></code> with points to define
voronoi regions if the user sets <code class="docutils literal"><span class="pre">r_ratio</span> <span class="pre">=</span> <span class="pre">1</span></code>. (use binratio)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
<li><strong>center</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim,)) &#8211; location of the center of the hyperrectangle</li>
<li><strong>r_size</strong> (<em>double or list()</em>) &#8211; size of the length of the sides of the
hyperrectangle rect_domain to definie voronoi cells for</li>
<li><strong>sur_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; minima and maxima of each dimension defining the
surrounding domain. The surrounding domain is the bounded domain
in the data space (i.e. the data domain).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">tuple</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(points, interior_and_layer1, rect_domain) where where points is
an <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (num_points, dim),
interior_and_layer1 is a list() of dim <code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray`s</span> <span class="pre">of</span> <span class="pre">shape</span>
<span class="pre">(center_pts_per_edge+2,),</span> <span class="pre">rect_domain</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">:class:`numpy.ndarray</span></code> of
shape (mdim, 2)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.edges_from_points">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">edges_from_points</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.edges_from_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of arrays describing the voronoi points in each dimension
that define a set of bounded hyperrectangular bins returns the edges of bins
formed by voronoi cells along each dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>points</strong> (list of dim <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (nbins+2,)) &#8211; the coordindates of voronoi points that would generate
these bins in each dimensions</td>
</tr>
<tr class="field-even field"><th class="field-name">Rtype edges:</th><td class="field-body">A list() containing mdim <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape
(nbins_per_dim+1,)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">edges, A sequence of arrays describing the edges of bins along
each dimension.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.edges_regular">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">edges_regular</code><span class="sig-paren">(</span><em>center_pts_per_edge</em>, <em>rect_domain</em>, <em>sur_domain</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.edges_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a sequence of arrays describing the edges of the finite voronoi
cells in each direction. The voronoi tesselation is defined by regular grid
of center points that define the voronoi tesselation of exactly the
interior of a hyperrectangle  defined by <code class="docutils literal"><span class="pre">rect_domain</span></code>  and the layers of
voronoi cells that bound these interior cells. The resulting voronoi
tesselation exactly represents the hyperrectangle. The bounding voronoi
cells are made finite by bounding them with an  additional layer to
represent <code class="docutils literal"><span class="pre">sur_domain</span></code>.</p>
<p>This method can also be used to tile <code class="docutils literal"><span class="pre">sur_domain</span></code> with points to define
voronoi regions if the user sets <code class="docutils literal"><span class="pre">r_ratio</span> <span class="pre">=</span> <span class="pre">1</span></code>. use binratio below</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center_pts_per_edge</strong> (<em>list</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
<li><strong>rect_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; The rectangular domain to define the voronoi
tesselation for. This domain should be contained in the <code class="docutils literal"><span class="pre">sur_domain</span></code>.</li>
<li><strong>sur_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; minima and maxima of each dimension defining the
surrounding domain. The surrounding domain is the bounded domain
in the data space (i.e. the data domain).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">tuple</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">interior_and_layer1 is a list of dim <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of
shape (center_pts_per_edge+2,)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.histogramdd_volumes">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">histogramdd_volumes</code><span class="sig-paren">(</span><em>edges</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.histogramdd_volumes" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of arrays describing the edges of voronoi cells (bins)
along each dimension and an <code class="docutils literal"><span class="pre">ij</span></code> ordered sequence of points (1 per voronoi
cell) returns a list of the volumes associated with these voronoi cells.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>edges</strong> (A list() containing mdim <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape
(nbins_per_dim+1,)) &#8211; A sequence of arrays describing the edges of bins along
each dimension.</li>
<li><strong>points</strong> (<code class="xref py py-class docutils literal"><span class="pre">numpy.ndarrray</span></code> of shape (num_points, mdim)) &#8211; points used to define the voronoi tesselation (only the
points that define regions of finite volumes)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">tuple of (H, volume, edges)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">H is the result of <code class="xref py py-meth docutils literal"><span class="pre">np.histogramdd(points,</span> <span class="pre">edges,</span>
<span class="pre">normed=True)()</span></code>, volumes is a <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape
(len(points),) continaing the  finite volumes associated with
<code class="docutils literal"><span class="pre">points</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.simple_fun_uniform">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">simple_fun_uniform</code><span class="sig-paren">(</span><em>points</em>, <em>volumes</em>, <em>rect_domain</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.simple_fun_uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of points, the volumes associated with these points, and
<code class="docutils literal"><span class="pre">rect_domain</span></code> creates a simple function approximation of a uniform
distribution over the hyperrectangle defined by <code class="docutils literal"><span class="pre">rect_domain</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>points</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (num_points,)) &#8211; points used to define the voronoi tesselation (only the
points that define regions of finite volumes)</li>
<li><strong>volumes</strong> (<em>list()</em>) &#8211; finite volumes associated with <code class="docutils literal"><span class="pre">points</span></code></li>
<li><strong>rect_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.11)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; minima and maxima of each dimension defining the
hyperrectangle of uniform probability</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal"><span class="pre">voronoi_sample_set</span></code></a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sample_set object defininng simple function approximation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-bet.calculateP">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-bet.calculateP" title="Permalink to this headline">¶</a></h2>
<p>This subpackage provides classes and methods for calulating the
probability measure <span class="math">\(P_{\Lambda}\)</span>.</p>
<ul>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#module-bet.calculateP.calculateP" title="bet.calculateP.calculateP"><code class="xref py py-mod docutils literal"><span class="pre">calculateP</span></code></a> provides methods for approximating</dt>
<dd><p class="first last">probability densities</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#module-bet.calculateP.simpleFunP" title="bet.calculateP.simpleFunP"><code class="xref py py-mod docutils literal"><span class="pre">simpleFunP</span></code></a> provides methods for creating simple</dt>
<dd><p class="first last">function approximations of probability densisties</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#module-bet.calculateP.voronoiHistogram" title="bet.calculateP.voronoiHistogram"><code class="xref py py-mod docutils literal"><span class="pre">voronoiHistogram</span></code></a> provides methods for creating the</dt>
<dd><p class="first last">generating points for cells that define a regular grid for use by
<code class="xref py py-meth docutils literal"><span class="pre">numpy.histogramdd()</span></code> and for determining their volumes, etc. This
module is only for use by <a class="reference internal" href="#module-bet.calculateP.simpleFunP" title="bet.calculateP.simpleFunP"><code class="xref py py-mod docutils literal"><span class="pre">simpleFunP</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#module-bet.calculateP.indicatorFunctions" title="bet.calculateP.indicatorFunctions"><code class="xref py py-mod docutils literal"><span class="pre">indicatorFunctions</span></code></a> provides methods for creating</dt>
<dd><p class="first last">indicator functions for use by various other classes.</p>
</dd>
</dl>
</li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="bet.postProcess.html" class="btn btn-neutral float-right" title="bet.postProcess package" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="bet.html" class="btn btn-neutral" title="bet package" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, The BET Development Team (Lindley Graham, Steven Mattis, Troy Butler).
      Last updated on Jun 25, 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.0.0-beta',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>