

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>bet.calculateP package &mdash; BET 3.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> BET
          

          
          </a>

          
            
            
              <div class="version">
                3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel.html">Parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_overview.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="todo_list.html">Todo List</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BET</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>bet.calculateP package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/bet.calculateP.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="bet-calculatep-package">
<h1>bet.calculateP package<a class="headerlink" href="#bet-calculatep-package" title="Permalink to this headline">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-bet.calculateP.calculateError">
<span id="bet-calculatep-calculateerror-module"></span><h2>bet.calculateP.calculateError module<a class="headerlink" href="#module-bet.calculateP.calculateError" title="Permalink to this headline">¶</a></h2>
<p>This module provides methods for calculating error estimates of
the probability measure for calculate probability measures. See
<cite>Butler et al. 2015. &lt;http://arxiv.org/pdf/1407.3851&gt;</cite>.</p>
<ul class="simple">
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">cell_connectivity_exact</span></code> calculates the connectivity of cells.</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">boundary_sets</span></code> calculates which cells are on the boundary and strictly interior for contour events.</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">sampling_error</span></code> is for calculating error estimates due to sampling.</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">model_error</span></code> is for calculating error estimates due to error in solution of QoIs</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.boundary_sets">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateError.</span></span><span class="sig-name descname"><span class="pre">boundary_sets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nei_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateError.boundary_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the the neighboring Voronoi cells for each cell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>disc</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.discretization</span></code></a>) – An object containing the discretization information.</p></li>
<li><p><strong>nei_list</strong> (<em>list</em>) – list of lists defining contour events of neighboring cells.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(<span class="math notranslate nohighlight">\(B_N, C_N\)</span>) where B_N are the cells strictly on the
interior of a contour event and C_N are the cells on the boundary
of a contour eventas defined in
<cite>Butler et al. 2015. &lt;http://arxiv.org/pdf/1407.3851&gt;</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.cell_connectivity_exact">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateError.</span></span><span class="sig-name descname"><span class="pre">cell_connectivity_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateError.cell_connectivity_exact" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates contour events of the cells and its neighbors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>disc</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.discretization</span></code></a>) – An object containing the discretization information.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>list of lists of neighboring cells</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.model_error">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateError.</span></span><span class="sig-name descname"><span class="pre">model_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateError.model_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A class for calculating the error due to numerical error
for a discretization.</p>
<dl class="py method">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.model_error.calculate_for_contour_events">
<span class="sig-name descname"><span class="pre">calculate_for_contour_events</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateError.model_error.calculate_for_contour_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the numerical error for each contour event.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">er_list</span></code>, a list of the error estimates
for each contour event.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.model_error.calculate_for_sample_set_region">
<span class="sig-name descname"><span class="pre">calculate_for_sample_set_region</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">region</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">emulated_set</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateError.model_error.calculate_for_sample_set_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the numerical error estimate for a region of the input space
defined by a sample set object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s_set</strong> (<a class="reference internal" href="bet.html#bet.sample.sample_set_base" title="bet.sample.sample_set_base"><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.sample_set_base</span></code></a>) – sample set for which to calculate error</p></li>
<li><p><strong>region</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) – region of s_set for which to calculate error</p></li>
<li><p><strong>emulated_set</strong> – sample set for volume emulation</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#float" title="(in Python v2.7)">float</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">er_est</span></code>, the numerical error estimate for the region</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.model_error.calculate_for_sample_set_region_mc">
<span class="sig-name descname"><span class="pre">calculate_for_sample_set_region_mc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">region</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateError.model_error.calculate_for_sample_set_region_mc" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the numerical error estimate for a region of the input space
defined by a sample set object, using the MC assumption.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s_set</strong> (<a class="reference internal" href="bet.html#bet.sample.sample_set_base" title="bet.sample.sample_set_base"><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.sample_set_base</span></code></a>) – sample set for which to calculate error</p></li>
<li><p><strong>region</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) – region of s_set for which to calculate error</p></li>
</ul>
</dd>
</dl>
<p>:rtype float
:returns: <code class="docutils literal notranslate"><span class="pre">er_est</span></code>, the numerical error estimate for the region</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.model_error.disc">
<span class="sig-name descname"><span class="pre">disc</span></span><a class="headerlink" href="#bet.calculateP.calculateError.model_error.disc" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.discretiztion</span></code> defining the problem</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.model_error.disc_new">
<span class="sig-name descname"><span class="pre">disc_new</span></span><a class="headerlink" href="#bet.calculateP.calculateError.model_error.disc_new" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.discretiztion</span></code> from adding error estimates</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.model_error.num">
<span class="sig-name descname"><span class="pre">num</span></span><a class="headerlink" href="#bet.calculateP.calculateError.model_error.num" title="Permalink to this definition">¶</a></dt>
<dd><p>number of inputs and outputs</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.sampling_error">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateError.</span></span><span class="sig-name descname"><span class="pre">sampling_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateError.sampling_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A class for calculating the error due to sampling for a discretization.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.sampling_error.B_N">
<span class="sig-name descname"><span class="pre">B_N</span></span><a class="headerlink" href="#bet.calculateP.calculateError.sampling_error.B_N" title="Permalink to this definition">¶</a></dt>
<dd><p>dictionaries of interior and boundary sets</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.sampling_error.C_N">
<span class="sig-name descname"><span class="pre">C_N</span></span><a class="headerlink" href="#bet.calculateP.calculateError.sampling_error.C_N" title="Permalink to this definition">¶</a></dt>
<dd><p>dictionaries of interior and boundary sets</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.sampling_error.calculate_for_contour_events">
<span class="sig-name descname"><span class="pre">calculate_for_contour_events</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateError.sampling_error.calculate_for_contour_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the sampling error bounds for each contour event.  If volumes
are already calculated these are used. If not, volume emulation is used
if an emulated input set exists.  Otherwise the MC assumption is
made.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(<code class="docutils literal notranslate"><span class="pre">up_list</span></code>, <code class="docutils literal notranslate"><span class="pre">low_list</span></code>) where <code class="docutils literal notranslate"><span class="pre">up_list</span></code> is a list of
the upper bounds for each contour event and <code class="docutils literal notranslate"><span class="pre">low_list</span></code> is a list
of the lower bounds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.sampling_error.calculate_for_sample_set_region">
<span class="sig-name descname"><span class="pre">calculate_for_sample_set_region</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">region</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">emulated_set</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateError.sampling_error.calculate_for_sample_set_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the sampling error bounds for a region of the input space
defined by a sample set object which defines an event <span class="math notranslate nohighlight">\(A\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s_set</strong> (<a class="reference internal" href="bet.html#bet.sample.sample_set_base" title="bet.sample.sample_set_base"><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.sample_set_base</span></code></a>) – sample set for which to calculate error</p></li>
<li><p><strong>region</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) – region of s_set for which to calculate error</p></li>
<li><p><strong>emulated_set</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample_set_base</span></code>) – sample set for volume emulation</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(<code class="docutils literal notranslate"><span class="pre">upper_bound</span></code>, <code class="docutils literal notranslate"><span class="pre">lower_bound</span></code>) the upper and lower bounds
for the error.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.sampling_error.disc">
<span class="sig-name descname"><span class="pre">disc</span></span><a class="headerlink" href="#bet.calculateP.calculateError.sampling_error.disc" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.discretization</span></code></a> that defines the problem</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.sampling_error.num">
<span class="sig-name descname"><span class="pre">num</span></span><a class="headerlink" href="#bet.calculateP.calculateError.sampling_error.num" title="Permalink to this definition">¶</a></dt>
<dd><p>number of inputs and outputs</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="bet.calculateP.calculateError.wrong_argument_type">
<em class="property"><span class="pre">exception</span> </em><span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateError.</span></span><span class="sig-name descname"><span class="pre">wrong_argument_type</span></span><a class="headerlink" href="#bet.calculateP.calculateError.wrong_argument_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Exception for when the argument is not one of the acceptible
types.</p>
</dd></dl>

</section>
<section id="module-bet.calculateP.calculateP">
<span id="bet-calculatep-calculatep-module"></span><h2>bet.calculateP.calculateP module<a class="headerlink" href="#module-bet.calculateP.calculateP" title="Permalink to this headline">¶</a></h2>
<p>This module provides methods for calculating the probability measure
<span class="math notranslate nohighlight">\(P_{\Lambda}\)</span>.</p>
<ul class="simple">
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">prob_on_emulated_samples</span></code> provides a skeleton class and calculates the probability for a set of emulation points.</p></li>
<li><p><a class="reference internal" href="#bet.calculateP.calculateP.prob" title="bet.calculateP.calculateP.prob"><code class="xref py py-mod docutils literal notranslate"><span class="pre">prob</span></code></a> estimates the probability based on pre-defined volumes.</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">prob_with_emulated</span></code> estimates the probability using volume emulation.</p></li>
<li><p><a class="reference internal" href="#bet.calculateP.calculateP.prob_from_sample_set" title="bet.calculateP.calculateP.prob_from_sample_set"><code class="xref py py-mod docutils literal notranslate"><span class="pre">prob_from_sample_set</span></code></a> estimates the probability based on probabilities from another</p></li>
</ul>
<p>sample set on the same space.</p>
<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateP.prob">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateP.</span></span><span class="sig-name descname"><span class="pre">prob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math notranslate nohighlight">\(P_{\Lambda}(\mathcal{V}_{\lambda_{samples}})\)</span>, the
probability associated with a set of  cells defined by the model
solves at <span class="math notranslate nohighlight">\((\lambda_{samples})\)</span> where the volumes of these
cells are provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>discretization</strong> (class:<cite>bet.sample.discretization</cite>) – An object containing the discretization information.</p></li>
<li><p><strong>globalize</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) – Makes local variables global.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateP.prob_from_discretization_input">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateP.</span></span><span class="sig-name descname"><span class="pre">prob_from_discretization_input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_new</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob_from_discretization_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math notranslate nohighlight">\(P_{\Lambda}(\mathcal{V}_{\lambda_{samples_new}})\)</span>
from <span class="math notranslate nohighlight">\(P_{\Lambda}(\mathcal{V}_{\lambda_{samples_old}})\)</span> where
<span class="math notranslate nohighlight">\(\lambda_{samples_old}\)</span> come from an input discretization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>disc</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">discretization</span></code></a>) – Discretiztion on which probabilities have already been
calculated</p></li>
<li><p><strong>set_new</strong> (<a class="reference internal" href="bet.html#bet.sample.sample_set_base" title="bet.sample.sample_set_base"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set_base</span></code></a>) – Sample set for which probabilities will be calculated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateP.prob_from_sample_set">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateP.</span></span><span class="sig-name descname"><span class="pre">prob_from_sample_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">set_old</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_new</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob_from_sample_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math notranslate nohighlight">\(P_{\Lambda}(\mathcal{V}_{\lambda_{samples_new}})\)</span>
from <span class="math notranslate nohighlight">\(P_{\Lambda}(\mathcal{V}_{\lambda_{samples_old}})\)</span> using
the MC assumption with respect to set_old.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>set_old</strong> (<a class="reference internal" href="bet.html#bet.sample.sample_set_base" title="bet.sample.sample_set_base"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set_base</span></code></a>) – Sample set on which probabilities have already been
calculated</p></li>
<li><p><strong>set_new</strong> (<a class="reference internal" href="bet.html#bet.sample.sample_set_base" title="bet.sample.sample_set_base"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set_base</span></code></a>) – Sample set for which probabilities will be calculated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateP.prob_from_sample_set_with_emulated_volumes">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateP.</span></span><span class="sig-name descname"><span class="pre">prob_from_sample_set_with_emulated_volumes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">set_old</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_emulate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob_from_sample_set_with_emulated_volumes" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math notranslate nohighlight">\(P_{\Lambda}(\mathcal{V}_{\lambda_{samples_new}})\)</span>
from <span class="math notranslate nohighlight">\(P_{\Lambda}(\mathcal{V}_{\lambda_{samples_old}})\)</span> using
a set of emulated points are distributed with respect to the
volume measure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>set_old</strong> (<a class="reference internal" href="bet.html#bet.sample.sample_set_base" title="bet.sample.sample_set_base"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set_base</span></code></a>) – Sample set on which probabilities have already been
calculated</p></li>
<li><p><strong>set_new</strong> (<a class="reference internal" href="bet.html#bet.sample.sample_set_base" title="bet.sample.sample_set_base"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set_base</span></code></a>) – Sample set for which probabilities will be calculated.</p></li>
<li><p><strong>set_emulate</strong> (<a class="reference internal" href="bet.html#bet.sample.sample_set_base" title="bet.sample.sample_set_base"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set_base</span></code></a>) – Sample set for volume emulation</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateP.prob_on_emulated_samples">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateP.</span></span><span class="sig-name descname"><span class="pre">prob_on_emulated_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob_on_emulated_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math notranslate nohighlight">\(P_{\Lambda}(\mathcal{V}_{\lambda_{emulate}})\)</span>, the
probability associated with a set of Voronoi cells defined by
<code class="docutils literal notranslate"><span class="pre">num_l_emulate</span></code> iid samples <span class="math notranslate nohighlight">\((\lambda_{emulate})\)</span>.
This is added to the emulated input sample set object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>discretization</strong> (class:<cite>bet.sample.discretization</cite>) – An object containing the discretization information.</p></li>
<li><p><strong>globalize</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) – Makes local variables global.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateP.prob_with_emulated_volumes">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateP.</span></span><span class="sig-name descname"><span class="pre">prob_with_emulated_volumes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretization</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob_with_emulated_volumes" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math notranslate nohighlight">\(P_{\Lambda}(\mathcal{V}_{\lambda_{samples}})\)</span>, the
probability associated with a set of  cells defined by the model
solves at <span class="math notranslate nohighlight">\((\lambda_{samples})\)</span> where the volumes are calculated
with the given emulated input points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>discretization</strong> (class:<cite>bet.sample.discretization</cite>) – An object containing the discretization information.</p></li>
<li><p><strong>globalize</strong> – Makes local variables global.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-bet.calculateP.calculateR">
<span id="bet-calculatep-calculater-module"></span><h2>bet.calculateP.calculateR module<a class="headerlink" href="#module-bet.calculateP.calculateR" title="Permalink to this headline">¶</a></h2>
<p>This module contains functions for the density-based approach that utilizes a ratio of observed to predicted densities
to update an initial density on the parameter space.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#bet.calculateP.calculateR.generate_output_kdes" title="bet.calculateP.calculateR.generate_output_kdes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generate_output_kdes()</span></code></a> generates KDEs on output sets.</p></li>
<li><p><a class="reference internal" href="#bet.calculateP.calculateR.invert_to_kde" title="bet.calculateP.calculateR.invert_to_kde"><code class="xref py py-meth docutils literal notranslate"><span class="pre">invert_to_kde()</span></code></a> solves SIP for weighted KDEs.</p></li>
<li><p><a class="reference internal" href="#bet.calculateP.calculateR.invert_to_gmm" title="bet.calculateP.calculateR.invert_to_gmm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">invert_to_gmm()</span></code></a> solves SIP for a Gaussian Mixture Model.</p></li>
<li><p><a class="reference internal" href="#bet.calculateP.calculateR.invert_to_multivariate_gaussian" title="bet.calculateP.calculateR.invert_to_multivariate_gaussian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">invert_to_multivariate_gaussian()</span></code></a> solves SIP for a multivariate Gaussian.</p></li>
<li><p><a class="reference internal" href="#bet.calculateP.calculateR.invert_to_random_variable" title="bet.calculateP.calculateR.invert_to_random_variable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">invert_to_random_variable()</span></code></a> solves SIP for random variables.</p></li>
<li><p><a class="reference internal" href="#bet.calculateP.calculateR.invert_rejection_sampling" title="bet.calculateP.calculateR.invert_rejection_sampling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">invert_rejection_sampling()</span></code></a> solves SIP with rejection sampling.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateR.generate_output_kdes">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateR.</span></span><span class="sig-name descname"><span class="pre">generate_output_kdes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bw_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateR.generate_output_kdes" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate Kernel Density Estimates on predicted and observed output sample sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>discretization</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.discretization</span></code></a>) – Discretization used to calculate KDes</p></li>
<li><p><strong>bw_method</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) – bandwidth method for <cite>scipy.stats.gaussian_kde</cite>.
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html</a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>prediction set, prediction kdes, observation set, observation kdes, number of clusters</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.discretization.sample_set</span></code>, list, <code class="xref py py-class docutils literal notranslate"><span class="pre">bet.discretization.sample_set</span></code>, list, int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateR.invert">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateR.</span></span><span class="sig-name descname"><span class="pre">invert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bw_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateR.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the data consistent stochastic inverse problem, solving for input sample weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>discretization</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.discretization</span></code></a>) – Discretization on which to perform inversion.</p></li>
<li><p><strong>bw_method</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) – bandwidth method for <cite>scipy.stats.gaussian_kde</cite>.
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html</a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>acceptance rate, mean acceptance rate, pointers for samples to clusters</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list, <cite>np.ndarray</cite>, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateR.invert_rejection_sampling">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateR.</span></span><span class="sig-name descname"><span class="pre">invert_rejection_sampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bw_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateR.invert_rejection_sampling" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the data consistent stochastic inverse problem by rejection sampling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>discretization</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.discretization</span></code></a>) – Discretization on which to perform inversion.</p></li>
<li><p><strong>bw_method</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) – bandwidth method for <cite>scipy.stats.gaussian_kde</cite>.
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html</a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>sample set containing samples</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.sample_set</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateR.invert_to_gmm">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateR.</span></span><span class="sig-name descname"><span class="pre">invert_to_gmm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bw_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateR.invert_to_gmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the data consistent stochastic inverse problem, solving for a Gaussian mixture model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>discretization</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.discretization</span></code></a>) – Discretization on which to perform inversion.</p></li>
<li><p><strong>bw_method</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) – bandwidth method for <cite>scipy.stats.gaussian_kde</cite>.
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html</a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>means, covariances, and weights for Gaussians</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list, list, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateR.invert_to_kde">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateR.</span></span><span class="sig-name descname"><span class="pre">invert_to_kde</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bw_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateR.invert_to_kde" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the data consistent stochastic inverse problem, solving for a weighted kernel density estimate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>discretization</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.discretization</span></code></a>) – Discretization on which to perform inversion.</p></li>
<li><p><strong>bw_method</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) – bandwidth method for <cite>scipy.stats.gaussian_kde</cite>.
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html</a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>marginal probabilities and cluster weights</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list, <cite>np.ndarray</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateR.invert_to_multivariate_gaussian">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateR.</span></span><span class="sig-name descname"><span class="pre">invert_to_multivariate_gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bw_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateR.invert_to_multivariate_gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the data consistent stochastic inverse problem, solving for a multivariate Gaussian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>discretization</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.discretization</span></code></a>) – Discretization on which to perform inversion.</p></li>
<li><p><strong>bw_method</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) – bandwidth method for <cite>scipy.stats.gaussian_kde</cite>.
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html</a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>marginal probabilities and cluster weights</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list, <cite>np.ndarray</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.calculateR.invert_to_random_variable">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.calculateR.</span></span><span class="sig-name descname"><span class="pre">invert_to_random_variable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_reweighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bw_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateR.invert_to_random_variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the data consistent stochastic inverse problem, fitting a random variable.</p>
<p><cite>rv</cite> can take multiple types of formats depending on type of distribution.</p>
<p>A string is used for the same distribution with default parameters in each dimension.
ex. rv = ‘uniform’ or rv = ‘beta’</p>
<p>A list or tuple of length 2 is used for the same distribution with  fixed user-defined parameters in each dimension
as a dictionary.
ex. rv = [‘uniform’, {‘floc’:-2, ‘fscale’:5}] or rv = [‘beta’, {‘fa’: 2, ‘fb’:5, ‘floc’:-2, ‘fscale’:5}]</p>
<p>A list of length dim which entries of lists or tuples of length 2 is used for different distributions with fixed
user-defined parameters in each dimension as a dictionary.
ex. rv = [[‘uniform’, {‘floc’:-2, ‘fscale’:5}],</p>
<blockquote>
<div><p>[‘beta’, {‘fa’: 2, ‘fb’:5, ‘floc’:-2, ‘fscale’:5}]]</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>discretization</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">bet.sample.discretization</span></code></a>) – Discretization on which to perform inversion.</p></li>
<li><p><strong>rv</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a><em>, </em><em>list</em><em>, or </em><em>tuple</em>) – Type and parameters for continuous random variables.</p></li>
<li><p><strong>num_reweighted</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) – number of reweighted samples for fitting</p></li>
<li><p><strong>bw_method</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) – bandwidth method for <cite>scipy.stats.gaussian_kde</cite>.
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html</a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>marginal probabilities and cluster weights</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list, <cite>np.ndarray</cite></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-bet.calculateP.simpleFunP">
<span id="bet-calculatep-simplefunp-module"></span><h2>bet.calculateP.simpleFunP module<a class="headerlink" href="#module-bet.calculateP.simpleFunP" title="Permalink to this headline">¶</a></h2>
<p>This module provides methods for creating simple function approximations to be
used by <a class="reference internal" href="#module-bet.calculateP.calculateP" title="bet.calculateP.calculateP"><code class="xref py py-mod docutils literal notranslate"><span class="pre">calculateP</span></code></a>. These simple function approximations
are returned as <cite>bet.sample.sample_set</cite> objects.</p>
<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.check_inputs">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">check_inputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q_ref</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.check_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks inputs to methods.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.check_inputs_no_reference">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">check_inputs_no_reference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.check_inputs_no_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks inputs to methods.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.check_type">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">check_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_set</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.check_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Add support for different data types that can be passed as keyword
arguments. Attempt to infer dimension and set it correctly.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.infer_Q">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">infer_Q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.infer_Q" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to infer reference value around which to define a sample set.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.normal_partition_normal_distribution">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">normal_partition_normal_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_d_emulate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.normal_partition_normal_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span> is a multivariate normal probability
density centered at <code class="docutils literal notranslate"><span class="pre">Q_ref</span></code> with standard deviation <code class="docutils literal notranslate"><span class="pre">std</span></code> using
<code class="docutils literal notranslate"><span class="pre">M</span></code> bins sampled from the given normal distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>) – Sample set that the probability measure is defined for.</p></li>
<li><p><strong>M</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) – Defines number M samples in D used to define
<span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an “art” -
play around with it and you can get reasonable results with a
relatively small number here like 50.</p></li>
<li><p><strong>num_d_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) – Number of samples used to emulate using an MC
assumption</p></li>
<li><p><strong>Q_ref</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> of size (mdim,)) – <span class="math notranslate nohighlight">\(Q(\lambda_{reference})\)</span></p></li>
<li><p><strong>std</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> of size (mdim,)) – The standard deviation of each QoI</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">voronoi_sample_set</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>sample_set object defining simple function approximation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.regular_partition_uniform_distribution_rectangle_domain">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">regular_partition_uniform_distribution_rectangle_domain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rect_domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cells_per_dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.regular_partition_uniform_distribution_rectangle_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function appoximation of <span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math notranslate nohighlight">\(\rho{\mathcal{D}, M}\)</span> is a uniform probablity density over the
hyperrectangular domain specified by <code class="docutils literal notranslate"><span class="pre">rect_domain</span></code>.</p>
<p>Since <span class="math notranslate nohighlight">\(\rho_\mathcal{D}\)</span> is a uniform distribution on a
hyperrectangle we are able to represent it exactly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>) – Sample set that the probability measure is defined for.</p></li>
<li><p><strong>rect_domain</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> of shape (2, mdim)) – The domain overwhich <span class="math notranslate nohighlight">\(\rho_\mathcal{D}\)</span> is
uniform.</p></li>
<li><p><strong>cells_per_dimension</strong> (<em>list</em>) – number of cells per dimension</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="bet.html#bet.sample.rectangle_sample_set" title="bet.sample.rectangle_sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">rectangle_sample_set</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>sample_set object defining simple function approximation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.regular_partition_uniform_distribution_rectangle_scaled">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">regular_partition_uniform_distribution_rectangle_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rect_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cells_per_dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.regular_partition_uniform_distribution_rectangle_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span> is a uniform probability density
centered at <code class="docutils literal notranslate"><span class="pre">Q_ref</span></code> (or the <code class="docutils literal notranslate"><span class="pre">reference_value</span></code>
of a sample set. If <code class="docutils literal notranslate"><span class="pre">Q_ref</span></code> is not given the reference value is used.)
with <code class="docutils literal notranslate"><span class="pre">rect_scale</span></code> of the width
of D.</p>
<p>Since rho_D is a uniform distribution on a hyperrectanlge we are able
to represent it exactly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>) – Sample set that the probability measure is defined for.</p></li>
<li><p><strong>rect_scale</strong> (<em>double</em><em> or </em><em>list</em>) – The scale used to determine the width of the
uniform distribution as <code class="docutils literal notranslate"><span class="pre">rect_size</span> <span class="pre">=</span> <span class="pre">(data_max-data_min)*rect_scale</span></code></p></li>
<li><p><strong>Q_ref</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> of size (mdim,)) – <span class="math notranslate nohighlight">\(Q(\lambda_{reference})\)</span></p></li>
<li><p><strong>cells_per_dimension</strong> (<em>list</em>) – number of cells per dimension</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="bet.html#bet.sample.rectangle_sample_set" title="bet.sample.rectangle_sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">rectangle_sample_set</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>sample_set object defining simple function approximation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.regular_partition_uniform_distribution_rectangle_size">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">regular_partition_uniform_distribution_rectangle_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rect_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cells_per_dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.regular_partition_uniform_distribution_rectangle_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span> is a uniform probability density
centered at <code class="docutils literal notranslate"><span class="pre">Q_ref</span></code> (or the <code class="docutils literal notranslate"><span class="pre">reference_value</span></code>
of a sample set. If <code class="docutils literal notranslate"><span class="pre">Q_ref</span></code> is not given the reference value is used)
with <code class="docutils literal notranslate"><span class="pre">rect_size</span></code> of the width of a hyperrectangle.</p>
<p>Since rho_D is a uniform distribution on a hyperrectanlge we can represent
it exactly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rect_size</strong> (<em>double</em><em> or </em><em>list</em>) – The size used to determine the width of the uniform
distribution</p></li>
<li><p><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>) – Sample set that the probability measure is defined for.</p></li>
<li><p><strong>Q_ref</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> of size (mdim,)) – <span class="math notranslate nohighlight">\(Q(\lambda_{reference})\)</span></p></li>
<li><p><strong>cells_per_dimension</strong> (<em>list</em>) – number of cells per dimension.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="bet.html#bet.sample.rectangle_sample_set" title="bet.sample.rectangle_sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">rectangle_sample_set</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>sample_set object defining simple function approximation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.uniform_partition_normal_distribution">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">uniform_partition_normal_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_d_emulate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_partition_normal_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span> is a multivariate normal probability
density centered at <code class="docutils literal notranslate"><span class="pre">Q_ref</span></code> with standard deviation <code class="docutils literal notranslate"><span class="pre">std</span></code> using
<code class="docutils literal notranslate"><span class="pre">M</span></code> bins sampled from a uniform distribution with a size 4 standard
deviations in each direction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>) – Sample set that the probability measure is defined for.</p></li>
<li><p><strong>M</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) – Defines number M samples in D used to define
<span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an “art” -
play around with it and you can get reasonable results with a
relatively small number here like 50.</p></li>
<li><p><strong>num_d_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) – Number of samples used to emulate using an MC
assumption</p></li>
<li><p><strong>Q_ref</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> of size (mdim,)) – <span class="math notranslate nohighlight">\(Q(\lambda_{reference})\)</span></p></li>
<li><p><strong>std</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> of size (mdim,)) – The standard deviation of each QoI</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">voronoi_sample_set</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>sample_set object defininng simple function approximation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_data_samples">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">uniform_partition_uniform_distribution_data_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_data_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span> is a uniform probability density over
the entire <code class="docutils literal notranslate"><span class="pre">data_domain</span></code>. Here the <code class="docutils literal notranslate"><span class="pre">data_domain</span></code> is the union of
Voronoi cells defined by <code class="docutils literal notranslate"><span class="pre">data</span></code>. In other words we assign each sample the
same probability, so <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">len(data)</span></code> or rather <code class="docutils literal notranslate"><span class="pre">len(d_distr_samples)</span> <span class="pre">==</span>
<span class="pre">len(data)</span></code>. The purpose of this method is to approximate uniform
distributions over irregularly shaped domains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">discretization</span></code></a>
or <a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>) – Sample set that the probability measure is defined for.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">voronoi_sample_set</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>sample_set object defininng simple function approximation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_rectangle_domain">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">uniform_partition_uniform_distribution_rectangle_domain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rect_domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_d_emulate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_rectangle_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math notranslate nohighlight">\(\rho_{\mathcal{D}}\)</span>
where <span class="math notranslate nohighlight">\(\rho_{\mathcal{D}}\)</span> is a uniform probability density on
a generalized rectangle defined by <code class="docutils literal notranslate"><span class="pre">rect_domain</span></code>.
The simple function approximation is then defined by determining <code class="docutils literal notranslate"><span class="pre">M</span></code>
Voronoi cells (i.e., “bins”) partitioning <span class="math notranslate nohighlight">\(\mathcal{D}\)</span>. These
bins are only implicitly defined by <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">``samples</span> <span class="pre">in</span> <span class="pre">:math:`\mathcal{D}`.</span>
<span class="pre">Finally,</span> <span class="pre">the</span> <span class="pre">probabilities</span> <span class="pre">of</span> <span class="pre">each</span> <span class="pre">of</span> <span class="pre">these</span> <span class="pre">bins</span> <span class="pre">is</span> <span class="pre">computed</span> <span class="pre">by</span>
<span class="pre">sampling</span> <span class="pre">from</span> <span class="pre">:math:`\rho{\mathcal{D}}`</span> <span class="pre">and</span> <span class="pre">using</span> <span class="pre">nearest</span> <span class="pre">neighbor</span>
<span class="pre">searches</span> <span class="pre">to</span> <span class="pre">bin</span> <span class="pre">these</span> <span class="pre">samples</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">``M</span></code> implicitly defined bins.
The result is the simple function approximation denoted by
<span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span>.</p>
<p>Note that all computations in the measure-based approach that
follow from this are for the fixed simple function approximation
<span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) – Defines number M samples in D used to define
<span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an “art” -
play around with it and you can get reasonable results with a
relatively small number here like 50.</p></li>
<li><p><strong>rect_domain</strong> (<em>double</em><em> or </em><em>list</em>) – The support of the density</p></li>
<li><p><strong>num_d_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) – Number of samples used to emulate using an MC
assumption</p></li>
<li><p><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>) – Sample set that the probability measure is defined for.</p></li>
<li><p><strong>Q_ref</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> of size (mdim,)) – <span class="math notranslate nohighlight">\(Q(\)</span>lambda_{reference})`</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">voronoi_sample_set</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>sample_set object defininng simple function approximation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_rectangle_scaled">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">uniform_partition_uniform_distribution_rectangle_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rect_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_d_emulate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_rectangle_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math notranslate nohighlight">\(\rho_{\mathcal{D}}\)</span>
where <span class="math notranslate nohighlight">\(\rho_{\mathcal{D}}\)</span> is a uniform probability density on
a generalized rectangle centered at <code class="docutils literal notranslate"><span class="pre">Q_ref</span></code> or the <code class="docutils literal notranslate"><span class="pre">reference_value</span></code>
of a sample set. If <code class="docutils literal notranslate"><span class="pre">Q_ref</span></code> is not given the reference value is used..
The support of this density is defined by <code class="docutils literal notranslate"><span class="pre">rect_scale</span></code>, which determines
the size of the generalized rectangle by scaling the circumscribing
generalized rectangle of <span class="math notranslate nohighlight">\(\mathcal{D}\)</span>.
The simple function approximation is then defined by determining <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">``</span>
<span class="pre">Voronoi</span> <span class="pre">cells</span> <span class="pre">(i.e.,</span> <span class="pre">&quot;bins&quot;)</span> <span class="pre">partitioning</span> <span class="pre">:math:`\mathcal{D}`.</span> <span class="pre">These</span>
<span class="pre">bins</span> <span class="pre">are</span> <span class="pre">only</span> <span class="pre">implicitly</span> <span class="pre">defined</span> <span class="pre">by</span> <span class="pre">``M</span></code> samples in <span class="math notranslate nohighlight">\(\mathcal{D}\)</span>.
Finally, the probabilities of each of these bins is computed by
sampling from <span class="math notranslate nohighlight">\(\rho{\mathcal{D}}\)</span> and using nearest neighbor
searches to bin these samples in the <code class="docutils literal notranslate"><span class="pre">M</span></code> implicitly defined bins.
The result is the simple function approximation denoted by
<span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span>.</p>
<p>Note that all computations in the measure-based approach that
follow from this are for the fixed simple function approximation
<span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) – Defines number M samples in D used to define
<span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an “art” -
play around with it and you can get reasonable results with a
relatively small number here like 50.</p></li>
<li><p><strong>rect_scale</strong> (<em>double</em><em> or </em><em>list</em>) – The scale used to determine the support of the
uniform distribution as <code class="docutils literal notranslate"><span class="pre">rect_size</span> <span class="pre">=</span> <span class="pre">(data_max-data_min)*rect_scale</span></code></p></li>
<li><p><strong>num_d_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) – Number of samples used to emulate using an MC
assumption</p></li>
<li><p><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>) – Sample set that the probability measure is defined for.</p></li>
<li><p><strong>Q_ref</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> of size (mdim,)) – <span class="math notranslate nohighlight">\(Q(\)</span>lambda_{reference})`</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">voronoi_sample_set</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>sample_set object defininng simple function approximation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_rectangle_size">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">uniform_partition_uniform_distribution_rectangle_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rect_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_d_emulate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_partition_uniform_distribution_rectangle_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math notranslate nohighlight">\(\rho_{\mathcal{D}}\)</span>
where <span class="math notranslate nohighlight">\(\rho_{\mathcal{D}}\)</span> is a uniform probability density on
a generalized rectangle centered at <code class="docutils literal notranslate"><span class="pre">Q_ref</span></code> or the <code class="docutils literal notranslate"><span class="pre">reference_value</span></code>
of a sample set. If <code class="docutils literal notranslate"><span class="pre">Q_ref</span></code> is not given the reference value is used.
The support of this density is defined by <code class="docutils literal notranslate"><span class="pre">rect_size</span></code>, which determines
the size of the generalized rectangle.
The simple function approximation is then defined by determining <code class="docutils literal notranslate"><span class="pre">M</span></code>
Voronoi cells (i.e., “bins”) partitioning <span class="math notranslate nohighlight">\(\mathcal{D}\)</span>. These
bins are only implicitly defined by <code class="docutils literal notranslate"><span class="pre">M</span></code> samples in <span class="math notranslate nohighlight">\(\mathcal{D}\)</span>.
Finally, the probabilities of each of these bins is computed by
sampling from <span class="math notranslate nohighlight">\(\rho{\mathcal{D}}\)</span> and using nearest neighbor
searches to bin these samples in the <code class="docutils literal notranslate"><span class="pre">M</span></code> implicitly defined bins.
The result is the simple function approximation denoted by
<span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">data_set</span></code> is only used to determine dimension.</p>
</div>
<p>Note that all computations in the measure-based approach that
follow from this are for the fixed simple function approximation
<span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) – Defines number M samples in D used to define
<span class="math notranslate nohighlight">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an “art” -
play around with it and you can get reasonable results with a
relatively small number here like 50.</p></li>
<li><p><strong>rect_size</strong> (<em>double</em><em> or </em><em>list</em>) – Determines the size of the support of the
uniform distribution on a generalized rectangle</p></li>
<li><p><strong>num_d_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) – Number of samples used to emulate using an MC
assumption</p></li>
<li><p><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">discretization</span></code></a>
or <a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>) – Sample set that the probability measure is defined for.</p></li>
<li><p><strong>Q_ref</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> of size (mdim,)) – <span class="math notranslate nohighlight">\(Q(\)</span>lambda_{reference})`</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">voronoi_sample_set</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>sample_set object defininng simple function approximation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.user_partition_user_distribution">
<span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">user_partition_user_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_partition_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_distribution_set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.user_partition_user_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a user defined simple function approximation of a user
defined distribution. The simple function discretization is
specified in the <code class="docutils literal notranslate"><span class="pre">data_partition_set</span></code>, and the set of i.i.d.
samples from the distribution is specified in the
<code class="docutils literal notranslate"><span class="pre">data_distribution_set</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>) – Sample set that the probability measure is defined for.</p></li>
<li><p><strong>data_partition_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>) – Sample set defining the discretization
of the data space into Voronoi cells for which a simple function
is defined upon.</p></li>
<li><p><strong>data_distribution_set</strong> (<a class="reference internal" href="bet.html#bet.sample.discretization" title="bet.sample.discretization"><code class="xref py py-class docutils literal notranslate"><span class="pre">discretization</span></code></a> or
<a class="reference internal" href="bet.html#bet.sample.sample_set" title="bet.sample.sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">sample_set</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>) – Sample set containing the i.i.d. samples
from the distribution on the data space that are binned within the
Voronoi cells implicitly defined by the data_discretization_set.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="bet.html#bet.sample.voronoi_sample_set" title="bet.sample.voronoi_sample_set"><code class="xref py py-class docutils literal notranslate"><span class="pre">voronoi_sample_set</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>sample_set object defininng simple function approximation</p>
</dd>
</dl>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="bet.calculateP.simpleFunP.wrong_argument_type">
<em class="property"><span class="pre">exception</span> </em><span class="sig-prename descclassname"><span class="pre">bet.calculateP.simpleFunP.</span></span><span class="sig-name descname"><span class="pre">wrong_argument_type</span></span><a class="headerlink" href="#bet.calculateP.simpleFunP.wrong_argument_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Exception for when the argument for data_set is not one of the acceptible
types.</p>
</dd></dl>

</section>
<section id="module-bet.calculateP">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-bet.calculateP" title="Permalink to this headline">¶</a></h2>
<p>This subpackage provides classes and methods for calculating the
probability measure <span class="math notranslate nohighlight">\(P_{\Lambda}\)</span>.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#module-bet.calculateP.calculateP" title="bet.calculateP.calculateP"><code class="xref py py-mod docutils literal notranslate"><span class="pre">calculateP</span></code></a> provides methods for approximating probability densities in the measure-based approach.</p></li>
<li><p><a class="reference internal" href="#module-bet.calculateP.simpleFunP" title="bet.calculateP.simpleFunP"><code class="xref py py-mod docutils literal notranslate"><span class="pre">simpleFunP</span></code></a> provides methods for creating simple function approximations of probability densities for the measure-based approach.</p></li>
<li><p><a class="reference internal" href="#module-bet.calculateP.calculateR" title="bet.calculateP.calculateR"><code class="xref py py-mod docutils literal notranslate"><span class="pre">calculateR</span></code></a> provides methods for density-based approach.</p></li>
<li><p><a class="reference internal" href="#module-bet.calculateP.calculateError" title="bet.calculateP.calculateError"><code class="xref py py-mod docutils literal notranslate"><span class="pre">calculateError</span></code></a> provides methods for approximating numerical and sampling errors.</p></li>
</ul>
</section>
</section>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, The BET Development Team (Lindley Graham, Steven Mattis, Troy Butler, Scott Walsh, Michael Pilosov)..
      <span class="lastupdated">
        Last updated on Jun 11, 2021.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>